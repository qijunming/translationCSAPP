[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.015625
Scroll Position: 824
Active Line: 838
Video Position: 141558

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.82,English,,0,0,0,,This come this will be the last lecture on machine level programming
Dialogue: 0,0:00:00.00,0:00:04.82,Chinese,,0,0,0,,这将是关于机器级编程的最后一次讲座
Dialogue: 0,0:00:05.42,0:00:09.94,English,,0,0,0,,We call it advanced topics but think of it more as miscellaneous topics
Dialogue: 0,0:00:05.42,0:00:09.94,Chinese,,0,0,0,,我们将其称为高级主题，但将其视为杂项主题
Dialogue: 0,0:00:10.70,0:00:16.00,English,,0,0,0,,And I think most to you of course you know that your bomb lab due tonight
Dialogue: 0,0:00:10.70,0:00:16.00,Chinese,,0,0,0,,我想你当然最了解你的炸弹实验室今晚到期了
Dialogue: 0,0:00:16.00,0:00:20.72,English,,0,0,0,,So you most year probably well into that or hopefully through it
Dialogue: 0,0:00:16.00,0:00:20.72,Chinese,,0,0,0,,所以你大部分时间都可能很好，或希望通过它
Dialogue: 0,0:00:21.08,0:00:26.44,English,,0,0,0,,And then at midnight tonight the next web will come out which is called attack lab
Dialogue: 0,0:00:21.08,0:00:26.44,Chinese,,0,0,0,,然后在今晚的午夜，下一个网络将出现，称为攻击实验室
Dialogue: 0,0:00:26.96,0:00:28.98,English,,0,0,0,,And there is a recitation about that yesterday
Dialogue: 0,0:00:26.96,0:00:28.98,Chinese,,0,0,0,,昨天有一个关于这个的背诵
Dialogue: 0,0:00:28.98,0:00:32.90,English,,0,0,0,,But this is a lab that's a new to the course
Dialogue: 0,0:00:28.98,0:00:32.90,Chinese,,0,0,0,,但这是一个实验室，是课程的新手
Dialogue: 0,0:00:33.36,0:00:37.50,English,,0,0,0,,It's a similar to one that we used to use at this point in the course
Dialogue: 0,0:00:33.36,0:00:37.50,Chinese,,0,0,0,,它类似于我们过去在课程中使用的那个
Dialogue: 0,0:00:37.64,0:00:41.60,English,,0,0,0,,But it's been updated and changed in significant ways
Dialogue: 0,0:00:37.64,0:00:41.60,Chinese,,0,0,0,,但它已经在很大程度上得到了更新和改变
Dialogue: 0,0:00:41.70,0:00:49.88,English,,0,0,0,,So we're actually when you have labs like we do in this course with this many students
Dialogue: 0,0:00:41.70,0:00:49.88,Chinese,,0,0,0,,所以我们实际上就像你在这个课程中有这么多学生一样的实验室
Dialogue: 0,0:00:49.88,0:00:51.90,English,,0,0,0,,There's a lot of things can go wrong
Dialogue: 0,0:00:49.88,0:00:51.90,Chinese,,0,0,0,,有很多事情可能会出错
Dialogue: 0,0:00:51.90,0:00:55.96,English,,0,0,0,,So we're going to keep a close eye on how things are going
Dialogue: 0,0:00:51.90,0:00:55.96,Chinese,,0,0,0,,因此，我们将密切关注事情的进展
Dialogue: 0,0:00:55.96,0:00:59.70,English,,0,0,0,,But I'd encourage you you only have a week and a half to do this next lab
Dialogue: 0,0:00:55.96,0:00:59.70,Chinese,,0,0,0,,但我鼓励你，你只有一个半星期的时间去做下一个实验
Dialogue: 0,0:01:00.10,0:01:05.10,English,,0,0,0,,To get started soon and partly by having some people start sooner
Dialogue: 0,0:01:00.10,0:01:05.10,Chinese,,0,0,0,,要尽快开始，部分是让一些人早点开始
Dialogue: 0,0:01:05.10,0:01:07.88,English,,0,0,0,,You'll start breaking things for us that we can track down
Dialogue: 0,0:01:05.10,0:01:07.88,Chinese,,0,0,0,,你将开始为我们打破我们可以追踪的事情
Dialogue: 0,0:01:09.56,0:01:16.94,English,,0,0,0,,So today what we'll talk about is a couple like I said it's miscellaneous topics but important topics
Dialogue: 0,0:01:09.56,0:01:16.94,Chinese,,0,0,0,,所以今天我们要谈的是一对夫妇，比如我说它是杂项主题，但重要的话题
Dialogue: 0,0:01:17.00,0:01:25.52,English,,0,0,0,,One is just sort of what does the memory look like when you're running x86-64 programs
Dialogue: 0,0:01:17.00,0:01:25.52,Chinese,,0,0,0,,一个是运行x86-64程序时内存的样子
Dialogue: 0,0:01:26.00,0:01:31.34,English,,0,0,0,,The other is a very important topic on security vulnerability called buffer overflows
Dialogue: 0,0:01:26.00,0:01:31.34,Chinese,,0,0,0,,另一个是关于安全漏洞的非常重要的主题，称为缓冲区溢出
Dialogue: 0,0:01:31.86,0:01:37.44,English,,0,0,0,,And in fact the attack lab will be precisely exploiting those security vulnerabilities
Dialogue: 0,0:01:31.86,0:01:37.44,Chinese,,0,0,0,,事实上，攻击实验室将正是利用这些安全漏洞
Dialogue: 0,0:01:37.96,0:01:43.02,English,,0,0,0,,And then we'll look at unions,so far you've booked it arrays and structs and how they're organized
Dialogue: 0,0:01:37.96,0:01:43.02,Chinese,,0,0,0,,然后我们会看看工会，到目前为止，你已经预订了数组和结构以及它们是如何组织的
Dialogue: 0,0:01:43.72,0:01:45.90,English,,0,0,0,,And I want to compare that to unions
Dialogue: 0,0:01:43.72,0:01:45.90,Chinese,,0,0,0,,我想把它与工会进行比较
Dialogue: 0,0:01:47.88,0:01:53.82,English,,0,0,0,,So let's talk about memory then as I said at the beginning early in the course
Dialogue: 0,0:01:47.88,0:01:53.82,Chinese,,0,0,0,,那么就像我在课程开始时所说的那样，让我们​​谈谈内存
Dialogue: 0,0:01:54.26,0:01:57.68,English,,0,0,0,,Conceptually a memory is just a big array of bytes
Dialogue: 0,0:01:54.26,0:01:57.68,Chinese,,0,0,0,,从概念上讲，内存只是一个很大的字节数组
Dialogue: 0,0:01:58.46,0:02:03.44,English,,0,0,0,,And that's the view of this the machine level programmer
Dialogue: 0,0:01:58.46,0:02:03.44,Chinese,,0,0,0,,这就是机器级程序员的看法
Dialogue: 0,0:02:03.72,0:02:05.84,English,,0,0,0,,Even though it's not the actual implementation
Dialogue: 0,0:02:03.72,0:02:05.84,Chinese,,0,0,0,,即使它不是实际的实现
Dialogue: 0,0:02:05.84,0:02:08.70,English,,0,0,0,,There's a whole part that we'll talk about later in the course
Dialogue: 0,0:02:05.84,0:02:08.70,Chinese,,0,0,0,,我们将在课程后期讨论整个部分
Dialogue: 0,0:02:09.58,0:02:11.84,English,,0,0,0,,Of this is called virtual memory
Dialogue: 0,0:02:09.58,0:02:11.84,Chinese,,0,0,0,,其中称为虚拟内存
Dialogue: 0,0:02:12.92,0:02:16.14,English,,0,0,0,,This organization is very simple organization
Dialogue: 0,0:02:12.92,0:02:16.14,Chinese,,0,0,0,,这个组织非常简单
Dialogue: 0,0:02:16.60,0:02:20.28,English,,0,0,0,,But the underlying implementation is this complex management of
Dialogue: 0,0:02:16.60,0:02:20.28,Chinese,,0,0,0,,但底层实施是这种复杂的管理
Dialogue: 0,0:02:20.88,0:02:27.52,English,,0,0,0,,Of various different memory types from disk memories to solid state disks
Dialogue: 0,0:02:20.88,0:02:27.52,Chinese,,0,0,0,,从磁盘存储器到固态磁盘的各种不同存储器类型
Dialogue: 0,0:02:28.00,0:02:32.60,English,,0,0,0,,And to what's called DRAM which stands for dynamic RAM the
Dialogue: 0,0:02:28.00,0:02:32.60,Chinese,,0,0,0,,而所谓的DRAM代表动态RAM
Dialogue: 0,0:02:32.80,0:02:35.88,English,,0,0,0,,When you buy memory for your processor its DRAM
Dialogue: 0,0:02:32.80,0:02:35.88,Chinese,,0,0,0,,当你为你的处理器购买内存时它的DRAM
Dialogue: 0,0:02:36.98,0:02:48.27,English,,0,0,0,,Um so as you know in x86-64 we're working with machines that nominally have addresses can be up to 64 bits long
Dialogue: 0,0:02:36.98,0:02:48.27,Chinese,,0,0,0,,嗯，你知道在x86-64我们正在使用名义上有地址的机器可以长达64位
Dialogue: 0,0:02:48.66,0:02:52.22,English,,0,0,0,,And if you work out the numbers remember I told you at the beginning of the course
Dialogue: 0,0:02:48.66,0:02:52.22,Chinese,,0,0,0,,如果你算出数字，记得我在课程开始时告诉过你
Dialogue: 0,0:02:52.22,0:03:00.28,English,,0,0,0,,You can estimate how big a number like to the 64 is by remembering that 1024
Dialogue: 0,0:02:52.22,0:03:00.28,Chinese,,0,0,0,,你可以通过记住1024来估计与64相似的数字
Dialogue: 0,0:03:00.82,0:03:03.22,English,,0,0,0,,And a thousand are very close to each other
Dialogue: 0,0:03:00.82,0:03:03.22,Chinese,,0,0,0,,千人彼此非常接近
Dialogue: 0,0:03:03.22,0:03:07.66,English,,0,0,0,,So 2^10 is roughly the same as 10^3
Dialogue: 0,0:03:03.22,0:03:07.66,Chinese,,0,0,0,,因此2 ^ 10与10 ^ 3大致相同
Dialogue: 0,0:03:08.52,0:03:11.48,English,,0,0,0,,So you take 64 and you think 60
Dialogue: 0,0:03:08.52,0:03:11.48,Chinese,,0,0,0,,所以你拿64，你认为60
Dialogue: 0,0:03:11.48,0:03:21.04,English,,0,0,0,,So how big is 2^60 well that's 6*10 and therefore it's 6*3,it's like 10^18
Dialogue: 0,0:03:11.48,0:03:21.04,Chinese,,0,0,0,,那么2 ^ 60井有多大6 * 10因此它是6 * 3，就像10 ^ 18
Dialogue: 0,0:03:22.28,0:03:27.00,English,,0,0,0,,And then you add the four to that that's 2^4 and 16
Dialogue: 0,0:03:22.28,0:03:27.00,Chinese,,0,0,0,,然后你将四个加到2 ^ 4和16
Dialogue: 0,0:03:27.00,0:03:30.58,English,,0,0,0,,So it's around 16*10^18 bytes
Dialogue: 0,0:03:27.00,0:03:30.58,Chinese,,0,0,0,,所以它大约是16 * 10 ^ 18字节
Dialogue: 0,0:03:31.64,0:03:40.26,English,,0,0,0,,So if you were to go off and look online on amazon for DRAM chips
Dialogue: 0,0:03:31.64,0:03:40.26,Chinese,,0,0,0,,所以，如果你想在亚马逊网上看看DRAM芯片
Dialogue: 0,0:03:40.26,0:03:44.74,English,,0,0,0,,And try to buy that much memory you'd find you're spending a lot of money
Dialogue: 0,0:03:40.26,0:03:44.74,Chinese,,0,0,0,,并尝试购买那么多内存，你会发现你花了很多钱
Dialogue: 0,0:03:45.66,0:03:52.60,English,,0,0,0,,More than you I don't know the numbers but it would be a lot of memory money
Dialogue: 0,0:03:45.66,0:03:52.60,Chinese,,0,0,0,,比你更多我不知道数字，但它会有很多记忆金
Dialogue: 0,0:03:53.06,0:03:55.16,English,,0,0,0,,And so you basically can't do it nowadays
Dialogue: 0,0:03:53.06,0:03:55.16,Chinese,,0,0,0,,所以你现在基本上不能这样做
Dialogue: 0,0:03:56.12,0:04:00.48,English,,0,0,0,,Tend to the and so...
Dialogue: 0,0:03:56.12,0:04:00.48,Chinese,,0,0,0,,倾向于等...
Dialogue: 0,0:04:02.28,0:04:09.72,English,,0,0,0,,Right now the machines limit you to actually only 47 bits worth of address in the address space
Dialogue: 0,0:04:02.28,0:04:09.72,Chinese,,0,0,0,,现在，机器限制你在地址空间中实际只有47位的地址
Dialogue: 0,0:04:10.54,0:04:19.28,English,,0,0,0,,I'll and so 2^47 again work that out that's like 256*10^12
Dialogue: 0,0:04:10.54,0:04:19.28,Chinese,,0,0,0,,我会这样2 ^ 47再次工作，那就像256 * 10 ^ 12
Dialogue: 0,0:04:19.28,0:04:21.82,English,,0,0,0,,So it's 256 terabytes
Dialogue: 0,0:04:19.28,0:04:21.82,Chinese,,0,0,0,,所以它是256太字节
Dialogue: 0,0:04:23.16,0:04:26.86,English,,0,0,0,,And as you know you can buy a disk drive now that has 8 terabytes
Dialogue: 0,0:04:23.16,0:04:26.86,Chinese,,0,0,0,,如你所知，你现在可以买一个8TB的磁盘驱动器
Dialogue: 0,0:04:26.86,0:04:28.36,English,,0,0,0,,So it doesn't seem like that much
Dialogue: 0,0:04:26.86,0:04:28.36,Chinese,,0,0,0,,所以看起来并不那么多
Dialogue: 0,0:04:28.36,0:04:37.54,English,,0,0,0,,But if you tried to buy that much DRAM again you'd have to have a pretty big credit-card limit
Dialogue: 0,0:04:28.36,0:04:37.54,Chinese,,0,0,0,,但如果你再次尝试购买那么多的DRAM，你必须有一个非常大的信用卡限制
Dialogue: 0,0:04:38.12,0:04:45.70,English,,0,0,0,,And so even that's a huge number and modern super computer installations actually will have almost that much memory
Dialogue: 0,0:04:38.12,0:04:45.70,Chinese,,0,0,0,,因此，即使这是一个庞大的数字和现代超级计算机安装实际上将有几乎那么多的记忆
Dialogue: 0,0:04:45.70,0:04:51.76,English,,0,0,0,,But the point is that the hardware of today limits you to 47 bits worth of address
Dialogue: 0,0:04:45.70,0:04:51.76,Chinese,,0,0,0,,但问题是，今天的硬件限制了你的47位地址
Dialogue: 0,0:04:52.56,0:04:58.18,English,,0,0,0,,But that's not really a real limitation in terms of of of actual machines
Dialogue: 0,0:04:52.56,0:04:58.18,Chinese,,0,0,0,,但就实际机器而言，这并不是真正的限制
Dialogue: 0,0:04:58.32,0:05:03.12,English,,0,0,0,,And what will happen is memory prices get cheaper and the technology gets better
Dialogue: 0,0:04:58.32,0:05:03.12,Chinese,,0,0,0,,会发生什么是内存价格变得更便宜，技术变得更好
Dialogue: 0,0:05:03.46,0:05:08.10,English,,0,0,0,,They'll slowly start adding as succeeding generations of processors come along
Dialogue: 0,0:05:03.46,0:05:08.10,Chinese,,0,0,0,,随着后续几代处理器的出现，它们将慢慢开始添加
Dialogue: 0,0:05:08.78,0:05:11.62,English,,0,0,0,,Let you have bigger and bigger range of addresses
Dialogue: 0,0:05:08.78,0:05:11.62,Chinese,,0,0,0,,让你拥有越来越大的地址范围
Dialogue: 0,0:05:12.52,0:05:17.30,English,,0,0,0,,So all that is to say that's why
Dialogue: 0,0:05:12.52,0:05:17.30,Chinese,,0,0,0,,所有这就是说这就是原因
Dialogue: 0,0:05:19.58,0:05:23.84,English,,0,0,0,,This number shows up which is a seven followed by eleven Fs
Dialogue: 0,0:05:19.58,0:05:23.84,Chinese,,0,0,0,,这个数字显示为7，然后是11个Fs
Dialogue: 0,0:05:27.76,0:05:32.68,English,,0,0,0,,I can tell I need to scribble some numbers you guys
Dialogue: 0,0:05:27.76,0:05:32.68,Chinese,,0,0,0,,我可以说我需要给你们一些数字
Dialogue: 0,0:05:32.68,0:05:35.56,English,,0,0,0,,Just saying numbers in the air is not working here
Dialogue: 0,0:05:32.68,0:05:35.56,Chinese,,0,0,0,,只是说空中的数字在这里不起作用
Dialogue: 0,0:05:36.88,0:05:49.88,English,,0,0,0,,So let's try
Dialogue: 0,0:05:36.88,0:05:49.88,Chinese,,0,0,0,,让我们试试吧
Dialogue: 0,0:05:50.20,0:05:53.96,English,,0,0,0,,Ok
Dialogue: 0,0:05:50.20,0:05:53.96,Chinese,,0,0,0,,好
Dialogue: 0,0:05:55.32,0:06:06.21,English,,0,0,0,,Okay so remember I said before to 2^64 is about equal to 16*10^18
Dialogue: 0,0:05:55.32,0:06:06.21,Chinese,,0,0,0,,好吧所以记得我之前说过2 ^ 64大约相当于16 * 10 ^ 18
Dialogue: 0,0:06:09.20,0:06:17.82,English,,0,0,0,,And 2^47 is 128*10^12
Dialogue: 0,0:06:09.20,0:06:17.82,Chinese,,0,0,0,,并且2 ^ 47是128 * 10 ^ 12
Dialogue: 0,0:06:19.24,0:06:21.14,English,,0,0,0,,So it's 128 terabytes
Dialogue: 0,0:06:19.24,0:06:21.14,Chinese,,0,0,0,,所以这是128太字节
Dialogue: 0,0:06:29.26,0:06:33.56,English,,0,0,0,,So what's the number after a terabyte you know 10^15
Dialogue: 0,0:06:29.26,0:06:33.56,Chinese,,0,0,0,,那么你知道10 ^ 15之后的数字是多少
Dialogue: 0,0:06:36.78,0:06:40.74,English,,0,0,0,,How many but yes petabytes right
Dialogue: 0,0:06:36.78,0:06:40.74,Chinese,,0,0,0,,多少，但是正确的是petabytes
Dialogue: 0,0:06:44.82,0:06:48.58,English,,0,0,0,,And you know what 10^18 is
Dialogue: 0,0:06:44.82,0:06:48.58,Chinese,,0,0,0,,你知道10 ^ 18是什么
Dialogue: 0,0:06:53.40,0:07:00.02,English,,0,0,0,,So just as a reference a company like google roughly
Dialogue: 0,0:06:53.40,0:07:00.02,Chinese,,0,0,0,,所以就像谷歌粗略的公司一样参考
Dialogue: 0,0:07:00.46,0:07:04.10,English,,0,0,0,,It's probably it's total storage across the whole
Dialogue: 0,0:07:00.46,0:07:04.10,Chinese,,0,0,0,,它可能是整个存储的总存储空间
Dialogue: 0,0:07:04.90,0:07:08.70,English,,0,0,0,,Enterprise is measured in some small number of x bytes
Dialogue: 0,0:07:04.90,0:07:08.70,Chinese,,0,0,0,,企业以少量x字节来衡量
Dialogue: 0,0:07:09.80,0:07:18.00,English,,0,0,0,,And it every day is getting several petabytes I don't know the numbers are of course secret
Dialogue: 0,0:07:09.80,0:07:18.00,Chinese,,0,0,0,,它每天都有几PB，我不知道这些数字当然是秘密的
Dialogue: 0,0:07:18.04,0:07:25.52,English,,0,0,0,,But maybe 10 petabytes or more per day of new data that it's ingesting into its system so
Dialogue: 0,0:07:18.04,0:07:25.52,Chinese,,0,0,0,,但是每天可能会有10 PB或更多的新数据被它摄入到它的系统中
Dialogue: 0,0:07:26.02,0:07:30.54,English,,0,0,0,,These numbers are pretty huge but not just totally off the charts
Dialogue: 0,0:07:26.02,0:07:30.54,Chinese,,0,0,0,,这些数字非常巨大，但不仅仅是完全脱离图表
Dialogue: 0,0:07:30.54,0:07:39.20,English,,0,0,0,,Do you know what 10^21 is? It's called a zettabyte with two t's
Dialogue: 0,0:07:30.54,0:07:39.20,Chinese,,0,0,0,,你知道10 ^ 21是什么吗？它被称为带有两个t的zettabyte
Dialogue: 0,0:07:41.54,0:07:45.90,English,,0,0,0,,And it's estimated if you add up all the digital content in the world
Dialogue: 0,0:07:41.54,0:07:45.90,Chinese,,0,0,0,,据估计，如果你将世界上所有的数字内容加起来
Dialogue: 0,0:07:45.90,0:07:49.90,English,,0,0,0,,That gets created everybody's cell phone camera every video
Dialogue: 0,0:07:45.90,0:07:49.90,Chinese,,0,0,0,,每个视频都会创建每个人的手机摄像头
Dialogue: 0,0:07:50.40,0:07:55.92,English,,0,0,0,,Taken by anyone anywhere all year long is a couple of zettabytes a year
Dialogue: 0,0:07:50.40,0:07:55.92,Chinese,,0,0,0,,全年任何人都可以使用一年两次的zettabytes
Dialogue: 0,0:07:55.96,0:08:02.30,English,,0,0,0,,So it'll be a while before we're really having to deal with that kind of memory
Dialogue: 0,0:07:55.96,0:08:02.30,Chinese,,0,0,0,,所以在我们真正处理这种记忆之前还需要一段时间
Dialogue: 0,0:08:03.18,0:08:10.36,English,,0,0,0,,So just to give you an idea so 128 terabytes is the address limit on these systems
Dialogue: 0,0:08:03.18,0:08:10.36,Chinese,,0,0,0,,所以只是为了给你一个想法，所以这些系统的地址限制为128太字节
Dialogue: 0,0:08:10.70,0:08:17.52,English,,0,0,0,,And so that's why you have to have seven because you remember that's one two three
Dialogue: 0,0:08:10.70,0:08:17.52,Chinese,,0,0,0,,所以这就是为什么你必须有七个，因为你记得那是一个二三
Dialogue: 0,0:08:18.22,0:08:26.10,English,,0,0,0,,And then there's f but there's 11 of them and this is 111 times 11
Dialogue: 0,0:08:18.22,0:08:26.10,Chinese,,0,0,0,,然后有f但是其中有11个，这是111次11
Dialogue: 0,0:08:26.10,0:08:31.32,English,,0,0,0,,So that's 44 ones and this is three ones
Dialogue: 0,0:08:26.10,0:08:31.32,Chinese,,0,0,0,,那是44个，这是三个
Dialogue: 0,0:08:33.44,0:08:36.44,English,,0,0,0,,And that's where you get 47
Dialogue: 0,0:08:33.44,0:08:36.44,Chinese,,0,0,0,,这就是你得到47的地方
Dialogue: 0,0:08:37.58,0:08:41.86,English,,0,0,0,,And that's the address of the in Linux
Dialogue: 0,0:08:37.58,0:08:41.86,Chinese,,0,0,0,,这就是Linux中的地址
Dialogue: 0,0:08:42.32,0:08:46.94,English,,0,0,0,,That's where they put the stack is up at the very top of the address space
Dialogue: 0,0:08:42.32,0:08:46.94,Chinese,,0,0,0,,这就是他们把堆栈放在地址空间最顶端的地方
Dialogue: 0,0:08:47.14,0:08:53.58,English,,0,0,0,,And I should tell you this picture is not at all to scale it would be impossible to draw this picture to scale
Dialogue: 0,0:08:47.14,0:08:53.58,Chinese,,0,0,0,,而且我应该告诉你，这张照片根本没有按比例绘制，因此无法按照比例绘制这张照片
Dialogue: 0,0:08:54.30,0:08:59.10,English,,0,0,0,,For example it shows that the stack starts way up at the top
Dialogue: 0,0:08:54.30,0:08:59.10,Chinese,,0,0,0,,例如，它显示堆栈从顶部开始向上
Dialogue: 0,0:08:59.10,0:09:03.10,English,,0,0,0,,And remember stacks grow to smaller addresses
Dialogue: 0,0:08:59.10,0:09:03.10,Chinese,,0,0,0,,并记住堆栈增长到较小的地址
Dialogue: 0,0:09:03.14,0:09:09.54,English,,0,0,0,,When you're pushing and also we show the them upside down just to make everything confusing
Dialogue: 0,0:09:03.14,0:09:09.54,Chinese,,0,0,0,,当你在推动时，我们也将它们颠倒过来，只是为了让一切变得混乱
Dialogue: 0,0:09:10.08,0:09:17.01,English,,0,0,0,,So the the stack starts there and it grows towards lower addresses
Dialogue: 0,0:09:10.08,0:09:17.01,Chinese,,0,0,0,,所以堆栈从那里开始，它朝着较低的地址增长
Dialogue: 0,0:09:17.32,0:09:20.50,English,,0,0,0,,And on a typical system it will be limited to 8 megabytes
Dialogue: 0,0:09:17.32,0:09:20.50,Chinese,,0,0,0,,在典型的系统上，它将限制在8兆字节
Dialogue: 0,0:09:20.78,0:09:23.98,English,,0,0,0,,And you can tell that on a Linux system at least
Dialogue: 0,0:09:20.78,0:09:23.98,Chinese,,0,0,0,,你至少可以在Linux系统上说出来
Dialogue: 0,0:09:25.38,0:09:28.78,English,,0,0,0,,With the the limit command
Dialogue: 0,0:09:25.38,0:09:28.78,Chinese,,0,0,0,,使用limit命令
Dialogue: 0,0:09:30.06,0:09:38.30,English,,0,0,0,,Which used to be more interesting than it was is now because a lot of things are unlimited
Dialogue: 0,0:09:30.06,0:09:38.30,Chinese,,0,0,0,,过去比现在更有趣，因为很多东西都是无限的
Dialogue: 0,0:09:38.76,0:09:43.76,English,,0,0,0,,But you see it says the stack size is limited to 8192 kbytes or kilobytes
Dialogue: 0,0:09:38.76,0:09:43.76,Chinese,,0,0,0,,但是你看到它表示堆栈大小限制为8192千字节或千字节
Dialogue: 0,0:09:43.76,0:09:46.12,English,,0,0,0,,So it's 8 megabytes
Dialogue: 0,0:09:43.76,0:09:46.12,Chinese,,0,0,0,,所以它是8兆字节
Dialogue: 0,0:09:49.96,0:10:00.77,English,,0,0,0,,And what that means is if you tried to access any memory via the stack pointer
Dialogue: 0,0:09:49.96,0:10:00.77,Chinese,,0,0,0,,这意味着如果你试图通过堆栈指针访问任何内存
Dialogue: 0,0:10:01.60,0:10:09.10,English,,0,0,0,,That was outside of the range of this 8 megabyte range you'd get a segmentation fault
Dialogue: 0,0:10:01.60,0:10:09.10,Chinese,,0,0,0,,这超出了这个8兆字节范围的范围，你会遇到分段错误
Dialogue: 0,0:10:10.40,0:10:17.74,English,,0,0,0,,And then down at the lower addresses what comes in what gets put into your program are the parts of the code
Dialogue: 0,0:10:10.40,0:10:17.74,Chinese,,0,0,0,,然后在较低的地址向下放入程序中的内容是代码的各个部分
Dialogue: 0,0:10:17.74,0:10:20.60,English,,0,0,0,,That that come out of the executable file
Dialogue: 0,0:10:17.74,0:10:20.60,Chinese,,0,0,0,,那个来自可执行文件
Dialogue: 0,0:10:20.94,0:10:25.10,English,,0,0,0,,And so there's a section and we'll talk more,when we talk about linking actually
Dialogue: 0,0:10:20.94,0:10:25.10,Chinese,,0,0,0,,所以有一个部分，当我们谈论实际链接时，我们会谈得更多
Dialogue: 0,0:10:25.10,0:10:28.36,English,,0,0,0,,About the way out of the memory and the different regions of it
Dialogue: 0,0:10:25.10,0:10:28.36,Chinese,,0,0,0,,关于记忆的方式和它的不同区域
Dialogue: 0,0:10:28.82,0:10:36.80,English,,0,0,0,,But for some obscure reason they call where the code is sitting the executable program the text segment
Dialogue: 0,0:10:28.82,0:10:36.80,Chinese,,0,0,0,,但是由于一些不明原因，他们称代码位于可执行程序的文本段
Dialogue: 0,0:10:36.81,0:10:41.90,English,,0,0,0,,I don't know why that's true, but it's the way it is and that's across many machines
Dialogue: 0,0:10:36.81,0:10:41.90,Chinese,,0,0,0,,我不知道为什么会这样，但它就是它的方式而且是在许多机器上
Dialogue: 0,0:10:42.30,0:10:49.89,English,,0,0,0,,And then the data is first of all there'll be a section for the data that's allocated at the program begins
Dialogue: 0,0:10:42.30,0:10:49.89,Chinese,,0,0,0,,然后数据首先会有一个部分用于在程序中分配的数据开始
Dialogue: 0,0:10:49.89,0:10:55.54,English,,0,0,0,,So any global variables that you've declared will be in that section
Dialogue: 0,0:10:49.89,0:10:55.54,Chinese,,0,0,0,,因此，你声明的任何全局变量都将出现在该部分中
Dialogue: 0,0:10:56.26,0:11:05.04,English,,0,0,0,,And then the heap is the part of memory that is x is allocated via call to malloc or one of its related functions
Dialogue: 0,0:10:56.26,0:11:05.04,Chinese,,0,0,0,,然后堆是内存的一部分，x是通过调用malloc或其相关函数之一来分配的
Dialogue: 0,0:11:05.06,0:11:08.16,English,,0,0,0,,And so that varies dynamically as the program runs
Dialogue: 0,0:11:05.06,0:11:08.16,Chinese,,0,0,0,,因此，程序运行时会动态变化
Dialogue: 0,0:11:08.72,0:11:13.30,English,,0,0,0,,It starts off with a very small allocation and every time you call malloc
Dialogue: 0,0:11:08.72,0:11:13.30,Chinese,,0,0,0,,它从一个非常小的分配开始，每次你调用malloc
Dialogue: 0,0:11:14.08,0:11:19.96,English,,0,0,0,,If you're not freeing memory and so your memory requirements keep growing
Dialogue: 0,0:11:14.08,0:11:19.96,Chinese,,0,0,0,,如果你没有释放内存，那么你的内存需求会不断增长
Dialogue: 0,0:11:20.20,0:11:25.68,English,,0,0,0,,It will crease keep up moving up larger and larger addresses
Dialogue: 0,0:11:20.20,0:11:25.68,Chinese,,0,0,0,,它会随着地址越来越大而不断增加
Dialogue: 0,0:11:26.16,0:11:30.18,English,,0,0,0,,And then somewhere in the code too and this can vary by system is
Dialogue: 0,0:11:26.16,0:11:30.18,Chinese,,0,0,0,,然后在代码中的某个地方，这可能因系统而异
Dialogue: 0,0:11:30.50,0:11:37.76,English,,0,0,0,,The code that gets brought in that represents the library functions things like printf and malloc itself
Dialogue: 0,0:11:30.50,0:11:37.76,Chinese,,0,0,0,,引入的代码表示库函数类似printf和malloc本身
Dialogue: 0,0:11:38.28,0:11:40.98,English,,0,0,0,,Our own library code they're stored off on disk
Dialogue: 0,0:11:38.28,0:11:40.98,Chinese,,0,0,0,,我们自己的库代码存储在磁盘上
Dialogue: 0,0:11:40.98,0:11:44.32,English,,0,0,0,,And they get brought in they get linked into your program
Dialogue: 0,0:11:40.98,0:11:44.32,Chinese,,0,0,0,,他们被引入，他们被链接到你的程序
Dialogue: 0,0:11:44.32,0:11:48.16,English,,0,0,0,,When it first starts executing by a process known as dynamic linking
Dialogue: 0,0:11:44.32,0:11:48.16,Chinese,,0,0,0,,当它首次通过称为动态链接的过程开始执行时
Dialogue: 0,0:11:48.32,0:11:51.74,English,,0,0,0,,Which we'll talk about later in the course too with the linking
Dialogue: 0,0:11:48.32,0:11:51.74,Chinese,,0,0,0,,我们将在后面的课程中讨论链接
Dialogue: 0,0:11:52.38,0:11:54.74,English,,0,0,0,,And what you'll find in general is that
Dialogue: 0,0:11:52.38,0:11:54.74,Chinese,,0,0,0,,你会发现一般的是
Dialogue: 0,0:11:55.30,0:11:59.02,English,,0,0,0,,Allocations will tend to be either at these very low addresses
Dialogue: 0,0:11:55.30,0:11:59.02,Chinese,,0,0,0,,分配将倾向于在这些非常低的地址
Dialogue: 0,0:11:59.38,0:12:03.74,English,,0,0,0,,Or these very high addresses as your program is running
Dialogue: 0,0:11:59.38,0:12:03.74,Chinese,,0,0,0,,或者在程序运行时这些非常高的地址
Dialogue: 0,0:12:06.72,0:12:09.44,English,,0,0,0,,So just as an example here is some code
Dialogue: 0,0:12:06.72,0:12:09.44,Chinese,,0,0,0,,所以这里只是一些代码
Dialogue: 0,0:12:09.84,0:12:15.08,English,,0,0,0,,Um that it's only value is to show you different where things get located
Dialogue: 0,0:12:09.84,0:12:15.08,Chinese,,0,0,0,,嗯它唯一的价值就是向你展示不同的地方
Dialogue: 0,0:12:15.50,0:12:19.50,English,,0,0,0,,And so you'll see I allocated some a fairly large arrays here
Dialogue: 0,0:12:15.50,0:12:19.50,Chinese,,0,0,0,,所以你会看到我在这里分配了一些相当大的数组
Dialogue: 0,0:12:19.50,0:12:26.60,English,,0,0,0,,This one is there all cares but this is 1<<24 so it's 16
Dialogue: 0,0:12:19.50,0:12:26.60,Chinese,,0,0,0,,这个是关注所有，但这是1 << 24所以它是16
Dialogue: 0,0:12:27.20,0:12:31.10,English,,0,0,0,,A megabyte array and this one is 1<<31
Dialogue: 0,0:12:27.20,0:12:31.10,Chinese,,0,0,0,,一个兆字节数组，这个是1 << 31
Dialogue: 0,0:12:31.88,0:12:37.10,English,,0,0,0,,So it's 2 gigabytes worth of array
Dialogue: 0,0:12:31.88,0:12:37.10,Chinese,,0,0,0,,所以这是2千兆字节的数组
Dialogue: 0,0:12:37.10,0:12:43.84,English,,0,0,0,,I found that if I tried to allocate larger ones it the program wouldn't run
Dialogue: 0,0:12:37.10,0:12:43.84,Chinese,,0,0,0,,我发现如果我试图分配更大的那个程序就不会运行
Dialogue: 0,0:12:44.82,0:12:51.92,English,,0,0,0,,And I also do some here's just a sort of global variable and here's a function
Dialogue: 0,0:12:44.82,0:12:51.92,Chinese,,0,0,0,,我也在这里做一些全局变量，这是一个函数
Dialogue: 0,0:12:52.90,0:12:56.94,English,,0,0,0,,And then there's a single function here with some local variable
Dialogue: 0,0:12:52.90,0:12:56.94,Chinese,,0,0,0,,然后这里有一个函数，带有一些局部变量
Dialogue: 0,0:12:56.94,0:12:59.60,English,,0,0,0,,And that will be allocated somewhere on the stack
Dialogue: 0,0:12:56.94,0:12:59.60,Chinese,,0,0,0,,这将被分配到堆栈的某个地方
Dialogue: 0,0:13:00.38,0:13:05.72,English,,0,0,0,,And then there's several calls to milk some of which are for some very small chunks of memory
Dialogue: 0,0:13:00.38,0:13:05.72,Chinese,,0,0,0,,然后有几次调用牛奶，其中一些用于一些非常小的内存
Dialogue: 0,0:13:06.04,0:13:08.94,English,,0,0,0,,And somewhere for some very large chunks of memory
Dialogue: 0,0:13:06.04,0:13:08.94,Chinese,,0,0,0,,还有某些非常大的内存块
Dialogue: 0,0:13:09.52,0:13:15.87,English,,0,0,0,,And so we can run this program and see what addresses pop out of it
Dialogue: 0,0:13:09.52,0:13:15.87,Chinese,,0,0,0,,所以我们可以运行这个程序，看看它弹出的地址
Dialogue: 0,0:13:16.34,0:13:19.08,English,,0,0,0,,And what you'll see is the stack
Dialogue: 0,0:13:16.34,0:13:19.08,Chinese,,0,0,0,,而你会看到的是堆栈
Dialogue: 0,0:13:19.48,0:13:24.94,English,,0,0,0,,This local variable is somewhere up with an address in the range of the stack
Dialogue: 0,0:13:19.48,0:13:24.94,Chinese,,0,0,0,,这个局部变量在某个地方有一个堆栈范围内的地址
Dialogue: 0,0:13:24.94,0:13:28.44,English,,0,0,0,,And you see the 7 and a couple fs and then it goes to something else
Dialogue: 0,0:13:24.94,0:13:28.44,Chinese,,0,0,0,,你看到7和几个fs然后它去了别的东西
Dialogue: 0,0:13:29.40,0:13:35.54,English,,0,0,0,,And you'll see also interestingly enough that the code and then looking down at the bottom
Dialogue: 0,0:13:29.40,0:13:35.54,Chinese,,0,0,0,,而且你会看到有趣的代码然后俯视底部
Dialogue: 0,0:13:36.60,0:13:42.62,English,,0,0,0,,Of this yellow color is things get relegated to the text segment the main function
Dialogue: 0,0:13:36.60,0:13:42.62,Chinese,,0,0,0,,这种黄色的东西被降级为文本段的主要功能
Dialogue: 0,0:13:42.94,0:13:46.50,English,,0,0,0,,And this function I called I declared called useless
Dialogue: 0,0:13:42.94,0:13:46.50,Chinese,,0,0,0,,而这个函数我叫我声称无用
Dialogue: 0,0:13:47.10,0:13:49.42,English,,0,0,0,,And then the predefined arrays
Dialogue: 0,0:13:47.10,0:13:49.42,Chinese,,0,0,0,,然后是预定义的数组
Dialogue: 0,0:13:50.58,0:13:55.16,English,,0,0,0,,That were in other words globally declared not declared by malloc
Dialogue: 0,0:13:50.58,0:13:55.16,Chinese,,0,0,0,,换句话说，全局声明不是由malloc声明的
Dialogue: 0,0:13:55.16,0:14:02.18,English,,0,0,0,,They're declared as part of the program itself are down here in this data section
Dialogue: 0,0:13:55.16,0:14:02.18,Chinese,,0,0,0,,它们被声明为程序本身的一部分，在此数据部分中
Dialogue: 0,0:14:02.75,0:14:08.52,English,,0,0,0,,And because it's a very large array, the huge array you actually get some fairly large addresses
Dialogue: 0,0:14:02.75,0:14:08.52,Chinese,,0,0,0,,而且因为它是一个非常大的数组，你实际上得到了一个相当大的地址
Dialogue: 0,0:14:09.26,0:14:11.12,English,,0,0,0,,And then interestingly enough
Dialogue: 0,0:14:09.26,0:14:11.12,Chinese,,0,0,0,,然后有趣的是
Dialogue: 0,0:14:11.66,0:14:15.56,English,,0,0,0,,Or I don't know why it's interesting but for one reason or another
Dialogue: 0,0:14:11.66,0:14:15.56,Chinese,,0,0,0,,或者我不知道为什么它有趣但是出于某种原因
Dialogue: 0,0:14:16.46,0:14:22.02,English,,0,0,0,,It happen that the smaller chunks of memory allocations
Dialogue: 0,0:14:16.46,0:14:22.02,Chinese,,0,0,0,,它发生在较小的内存分配块上
Dialogue: 0,0:14:22.34,0:14:28.74,English,,0,0,0,,Are down here at addresses that are actually just a little bit above  the the pink section right
Dialogue: 0,0:14:22.34,0:14:28.74,Chinese,,0,0,0,,在这里的地址实际上只是粉红色部分的正上方
Dialogue: 0,0:14:29.06,0:14:32.30,English,,0,0,0,,And similarly the really big chunks of memory I allocate
Dialogue: 0,0:14:29.06,0:14:32.30,Chinese,,0,0,0,,同样，我分配的内存非常庞大
Dialogue: 0,0:14:32.48,0:14:38.62,English,,0,0,0,,Are way up here near the stack limit
Dialogue: 0,0:14:32.48,0:14:38.62,Chinese,,0,0,0,,是在堆栈限制附近的方式
Dialogue: 0,0:14:39.28,0:14:43.60,English,,0,0,0,,And they are...
Dialogue: 0,0:14:39.28,0:14:43.60,Chinese,,0,0,0,,他们是......
Dialogue: 0,0:14:43.68,0:14:47.94,English,,0,0,0,,And so they're there and in general what's happening is if I were to try and reference
Dialogue: 0,0:14:43.68,0:14:47.94,Chinese,,0,0,0,,所以他们就在那里，总的来说，如果我试着参考的话会发生什么
Dialogue: 0,0:14:48.50,0:14:53.07,English,,0,0,0,,A memory address in this empty range I'd get a segmentation fault
Dialogue: 0,0:14:48.50,0:14:53.07,Chinese,,0,0,0,,在这个空范围内的内存地址我会得到一个分段错误
Dialogue: 0,0:14:53.46,0:14:57.96,English,,0,0,0,,It's a valid address in terms of its bit of properties
Dialogue: 0,0:14:53.46,0:14:57.96,Chinese,,0,0,0,,就其位属性而言，它是一个有效的地址
Dialogue: 0,0:14:57.96,0:15:03.10,English,,0,0,0,,But it hasn't actually been set up and allocated by the memory the virtual memory allocator
Dialogue: 0,0:14:57.96,0:15:03.10,Chinese,,0,0,0,,但它实际上并没有由内存设置和分配虚拟内存分配器
Dialogue: 0,0:15:03.10,0:15:06.10,English,,0,0,0,,So at any given time the valid addresses
Dialogue: 0,0:15:03.10,0:15:06.10,Chinese,,0,0,0,,所以在任何给定时间有效地址
Dialogue: 0,0:15:06.46,0:15:12.00,English,,0,0,0,,Are just those in the lower portion or the upper portion of this address ranges
Dialogue: 0,0:15:06.46,0:15:12.00,Chinese,,0,0,0,,只是位于此地址范围的下部或上部的那些
Dialogue: 0,0:15:12.24,0:15:14.16,English,,0,0,0,,And the middle is sort of no-man's land
Dialogue: 0,0:15:12.24,0:15:14.16,Chinese,,0,0,0,,中间是一种无人的土地
Dialogue: 0,0:15:14.38,0:15:17.44,English,,0,0,0,,And then what happens is you keep allocating more with malloc
Dialogue: 0,0:15:14.38,0:15:17.44,Chinese,,0,0,0,,然后会发生什么事情，你继续用malloc分配更多
Dialogue: 0,0:15:17.86,0:15:22.46,English,,0,0,0,,And it will push the limits of what's addressable in toward it
Dialogue: 0,0:15:17.86,0:15:22.46,Chinese,,0,0,0,,它将推动可解决的极限
Dialogue: 0,0:15:22.86,0:15:29.46,English,,0,0,0,,And in principle if you ever got too much of a memory request
Dialogue: 0,0:15:22.86,0:15:29.46,Chinese,,0,0,0,,原则上，如果你有太多的内存请求
Dialogue: 0,0:15:29.48,0:15:35.26,English,,0,0,0,,These two would hit each other and you and malik would return zero at that point
Dialogue: 0,0:15:29.48,0:15:35.26,Chinese,,0,0,0,,这两个会相互碰撞，你和malik会在那时返回零
Dialogue: 0,0:15:35.64,0:15:43.26,English,,0,0,0,,But it's highly unlikely given that you have 128 terabytes of (memory) address range here
Dialogue: 0,0:15:35.64,0:15:43.26,Chinese,,0,0,0,,但鉴于此处有128 TB的（内存）地址范围，这种可能性极小
Dialogue: 0,0:15:44.06,0:15:46.94,English,,0,0,0,,So that just and you've probably seen this when you're running
Dialogue: 0,0:15:44.06,0:15:46.94,Chinese,,0,0,0,,所以你刚刚跑步时就已经看过这个了
Dialogue: 0,0:15:47.48,0:15:50.50,English,,0,0,0,,You're looking at disassembled code with GDB
Dialogue: 0,0:15:47.48,0:15:50.50,Chinese,,0,0,0,,你正在查看使用GDB的反汇编代码
Dialogue: 0,0:15:50.50,0:15:56.76,English,,0,0,0,,You're seeing some addresses that are way up here with the 7 and some f so they're stack addresses
Dialogue: 0,0:15:50.50,0:15:56.76,Chinese,,0,0,0,,你看到一些地址在这里与7和一些f，所以他们是堆栈地址
Dialogue: 0,0:15:57.20,0:15:58.82,English,,0,0,0,,And you see these fours
Dialogue: 0,0:15:57.20,0:15:58.82,Chinese,,0,0,0,,而且你看到了这些四肢
Dialogue: 0,0:15:59.56,0:16:03.90,English,,0,0,0,,You know a lot of zeros and some fours those tend to be where the code is going
Dialogue: 0,0:15:59.56,0:16:03.90,Chinese,,0,0,0,,你知道很多零和四个那些往往是代码的地方
Dialogue: 0,0:16:04.32,0:16:09.28,English,,0,0,0,,Question
Dialogue: 0,0:16:04.32,0:16:09.28,Chinese,,0,0,0,,题
Dialogue: 0,0:16:09.42,0:16:12.34,English,,0,0,0,,Why doesn't the heat proceed in one direction I actually don't know
Dialogue: 0,0:16:09.42,0:16:12.34,Chinese,,0,0,0,,为什么热量不会沿着我实际上不知道的方向前进
Dialogue: 0,0:16:13.04,0:16:18.32,English,,0,0,0,,I'll just observe that it was had a strategy of putting big things here in small things here
Dialogue: 0,0:16:13.04,0:16:18.32,Chinese,,0,0,0,,我只是观察它有一个策略，在这里把小东西放在这里
Dialogue: 0,0:16:18.32,0:16:22.88,English,,0,0,0,,And it probably uses different slightly different management strategies for those two
Dialogue: 0,0:16:18.32,0:16:22.88,Chinese,,0,0,0,,它可能会对这两者采用不同的略有不同的管理策略
Dialogue: 0,0:16:33.10,0:16:38.74,English,,0,0,0,,Okay so that I think you'll find that kind of useful to have some sense when you're looking at
Dialogue: 0,0:16:33.10,0:16:38.74,Chinese,,0,0,0,,好的，所以我觉得你会发现在你看的时候有一点意义
Dialogue: 0,0:16:39.20,0:16:45.20,English,,0,0,0,,When you're running GDB it helps to just have some idea of what's going on when you're looking at these different addresses
Dialogue: 0,0:16:39.20,0:16:45.20,Chinese,,0,0,0,,当你运行GDB时，只需了解一下当你查看这些不同的地址时会发生什么
Dialogue: 0,0:16:47.36,0:16:50.44,English,,0,0,0,,Okay now let's talk about buffer overflow
Dialogue: 0,0:16:47.36,0:16:50.44,Chinese,,0,0,0,,好的，现在让我们谈谈缓冲区溢出
Dialogue: 0,0:16:50.92,0:16:55.34,English,,0,0,0,,And we'll start this you remember on the very first class
Dialogue: 0,0:16:50.92,0:16:55.34,Chinese,,0,0,0,,我们将在第一堂课时开始记得
Dialogue: 0,0:16:55.34,0:16:58.48,English,,0,0,0,,And I think we might have reviewed this part way along
Dialogue: 0,0:16:55.34,0:16:58.48,Chinese,,0,0,0,,我想我们可能已经审查了这一部分
Dialogue: 0,0:16:58.80,0:17:04.78,English,,0,0,0,,We showed this example of some programs where if you do an out-of-bounds
Dialogue: 0,0:16:58.80,0:17:04.78,Chinese,,0,0,0,,我们展示了一些程序的例子，如果你做了一个越界
Dialogue: 0,0:17:06.18,0:17:10.08,English,,0,0,0,,Reference and write a value that's out of bounds in particular
Dialogue: 0,0:17:06.18,0:17:10.08,Chinese,,0,0,0,,引用并写出特别超出范围的值
Dialogue: 0,0:17:10.96,0:17:14.60,English,,0,0,0,,I only have a array of two elements here
Dialogue: 0,0:17:10.96,0:17:14.60,Chinese,,0,0,0,,我这里只有两个元素的数组
Dialogue: 0,0:17:15.00,0:17:18.20,English,,0,0,0,,But this function will take an arbitrary value of i
Dialogue: 0,0:17:15.00,0:17:18.20,Chinese,,0,0,0,,但是这个函数将取i的任意值
Dialogue: 0,0:17:18.54,0:17:23.04,English,,0,0,0,,And assign some magic number to ailment i of the array
Dialogue: 0,0:17:18.54,0:17:23.04,Chinese,,0,0,0,,并为阵列的疾病i分配一些魔法数字
Dialogue: 0,0:17:24.06,0:17:25.86,English,,0,0,0,,And it has the possibility of...
Dialogue: 0,0:17:24.06,0:17:25.86,Chinese,,0,0,0,,它有可能......
Dialogue: 0,0:17:27.88,0:17:30.28,English,,0,0,0,,And we saw that when you do that
Dialogue: 0,0:17:27.88,0:17:30.28,Chinese,,0,0,0,,当你这样做时，我们看到了
Dialogue: 0,0:17:30.38,0:17:33.24,English,,0,0,0,,If I gets too big it will first
Dialogue: 0,0:17:30.38,0:17:33.24,Chinese,,0,0,0,,如果我变得太大，它将首先
Dialogue: 0,0:17:33.98,0:17:39.12,English,,0,0,0,,Corrupt the the double that stored is part of the struct
Dialogue: 0,0:17:33.98,0:17:39.12,Chinese,,0,0,0,,腐蚀存储的双重结构的一部分
Dialogue: 0,0:17:39.52,0:17:42.42,English,,0,0,0,,And then when it gets bigger it seems to
Dialogue: 0,0:17:39.52,0:17:42.42,Chinese,,0,0,0,,然后当它变大时，它似乎
Dialogue: 0,0:17:42.92,0:17:47.16,English,,0,0,0,,Not have any effect until it gets too big and then you start corrupting memory
Dialogue: 0,0:17:42.92,0:17:47.16,Chinese,,0,0,0,,在它变得太大然后你开始破坏内存之前没有任何影响
Dialogue: 0,0:17:47.74,0:17:54.20,English,,0,0,0,,So the basic point is that it's very easy in a program, a C program in particular
Dialogue: 0,0:17:47.74,0:17:54.20,Chinese,,0,0,0,,所以基本点是它在程序中非常容易，特别是C程序
Dialogue: 0,0:17:54.56,0:17:59.60,English,,0,0,0,,To a reference memory that's not part of the sort of intent of the program
Dialogue: 0,0:17:54.56,0:17:59.60,Chinese,,0,0,0,,对于不属于程序意图类型的参考存储器
Dialogue: 0,0:18:02.20,0:18:09.50,English,,0,0,0,,And this can happen in programs that aren't properly written that
Dialogue: 0,0:18:02.20,0:18:09.50,Chinese,,0,0,0,,这可能发生在没有正确编写的程序中
Dialogue: 0,0:18:10.32,0:18:19.66,English,,0,0,0,,And it becomes a security vulnerability if there's some way for an outsider to overflow a buffer
Dialogue: 0,0:18:10.32,0:18:19.66,Chinese,,0,0,0,,如果局外人有一些方法来溢出缓冲区，它就成了一个安全漏洞
Dialogue: 0,0:18:20.24,0:18:25.20,English,,0,0,0,,For example if there is some way for an outsider to give a larger value of i and ask that
Dialogue: 0,0:18:20.24,0:18:25.20,Chinese,,0,0,0,,例如，如果局外人有某种方式可以给出更大的i值并且要求它
Dialogue: 0,0:18:25.70,0:18:28.42,English,,0,0,0,,That value be stored there it could crash the program
Dialogue: 0,0:18:25.70,0:18:28.42,Chinese,,0,0,0,,该值存储在那里可能导致程序崩溃
Dialogue: 0,0:18:29.34,0:18:33.98,English,,0,0,0,,And so in general when you write in code you try to think about  can I trust this value
Dialogue: 0,0:18:29.34,0:18:33.98,Chinese,,0,0,0,,所以一般来说，当你在代码中编写时，你试着想一想我是否可以相信这个价值
Dialogue: 0,0:18:33.98,0:18:39.84,English,,0,0,0,,This a value that's been computed by my program and I'm sure that it's within bounds
Dialogue: 0,0:18:33.98,0:18:39.84,Chinese,,0,0,0,,这个值是由我的程序计算出来的，我确信它在界限范围内
Dialogue: 0,0:18:40.20,0:18:43.36,English,,0,0,0,,Or is it something that's come from an external source
Dialogue: 0,0:18:40.20,0:18:43.36,Chinese,,0,0,0,,或者它是来自外部来源的东西
Dialogue: 0,0:18:43.36,0:18:48.16,English,,0,0,0,,And there is potentially that risk of being a vulnerability
Dialogue: 0,0:18:43.36,0:18:48.16,Chinese,,0,0,0,,并且存在潜在的漏洞风险
Dialogue: 0,0:18:49.58,0:18:53.22,English,,0,0,0,,And so in particular there's a lot a huge class of errors
Dialogue: 0,0:18:49.58,0:18:53.22,Chinese,,0,0,0,,特别是有很多错误
Dialogue: 0,0:18:53.22,0:18:57.68,English,,0,0,0,,That have to do with overflowing buffers where
Dialogue: 0,0:18:53.22,0:18:57.68,Chinese,,0,0,0,,这与溢出缓冲区有关
Dialogue: 0,0:18:58.16,0:19:04.94,English,,0,0,0,,Where they're trying to store a string of some type that's been read from a message
Dialogue: 0,0:18:58.16,0:19:04.94,Chinese,,0,0,0,,他们试图存储从消息中读取的某种类型的字符串
Dialogue: 0,0:19:05.70,0:19:10.38,English,,0,0,0,,And without knowing in advance how big that string is
Dialogue: 0,0:19:05.70,0:19:10.38,Chinese,,0,0,0,,并且事先不知道该字符串有多大
Dialogue: 0,0:19:10.38,0:19:14.90,English,,0,0,0,,It's possible that it will be too big for the buffer that's been allocated
Dialogue: 0,0:19:10.38,0:19:14.90,Chinese,,0,0,0,,对于已分配的缓冲区，它可能太大了
Dialogue: 0,0:19:15.48,0:19:21.72,English,,0,0,0,,And so one of the culprits is there's a whole class of library functions that
Dialogue: 0,0:19:15.48,0:19:21.72,Chinese,,0,0,0,,因此，其中一个罪魁祸首就是有一整套库函数
Dialogue: 0,0:19:22.32,0:19:30.04,English,,0,0,0,,Let you store something a string somewhere without any kind of bounds checking even being possible
Dialogue: 0,0:19:22.32,0:19:30.04,Chinese,,0,0,0,,让你在某个地方存储一些字符串，即使可能也没有任何边界检查
Dialogue: 0,0:19:30.73,0:19:34.70,English,,0,0,0,,So the sort of worst one is one called gets
Dialogue: 0,0:19:30.73,0:19:34.70,Chinese,,0,0,0,,所以最糟糕的一种叫做获取
Dialogue: 0,0:19:35.20,0:19:39.58,English,,0,0,0,,And the purpose of gets is normally it's used to read a string from
Dialogue: 0,0:19:35.20,0:19:39.58,Chinese,,0,0,0,,get的目的通常是用来从中读取字符串
Dialogue: 0,0:19:40.18,0:19:46.00,English,,0,0,0,,An input from a terminal input something that somebody's typed into a terminal
Dialogue: 0,0:19:40.18,0:19:46.00,Chinese,,0,0,0,,来自终端的输入输入某人键入终端的内容
Dialogue: 0,0:19:46.38,0:19:50.14,English,,0,0,0,,And so what it's doing is it's scanning this input string
Dialogue: 0,0:19:46.38,0:19:50.14,Chinese,,0,0,0,,所以它正在做的是扫描这个输入字符串
Dialogue: 0,0:19:50.46,0:19:54.76,English,,0,0,0,,And looking for a character that represents the end of the line
Dialogue: 0,0:19:50.46,0:19:54.76,Chinese,,0,0,0,,并寻找代表该行结束的角色
Dialogue: 0,0:19:54.94,0:19:59.14,English,,0,0,0,,Which we write in of cea's is backslash n
Dialogue: 0,0:19:54.94,0:19:59.14,Chinese,,0,0,0,,我们用cea写的是反斜杠n
Dialogue: 0,0:19:59.48,0:20:02.94,English,,0,0,0,,And it has a character code at hex of 0a
Dialogue: 0,0:19:59.48,0:20:02.94,Chinese,,0,0,0,,它有一个十六进制的字符代码
Dialogue: 0,0:20:04.58,0:20:11.28,English,,0,0,0,,And so gets this is sort of an approximate version of what the code for gets looks like
Dialogue: 0,0:20:04.58,0:20:11.28,Chinese,,0,0,0,,因此得到这是一个近似版本的代码获取的样子
Dialogue: 0,0:20:11.78,0:20:17.02,English,,0,0,0,,That and it's as an argument it's just given a destination of where to store the result
Dialogue: 0,0:20:11.78,0:20:17.02,Chinese,,0,0,0,,那就是它作为一个参数，它只是给出了存储结果的目的地
Dialogue: 0,0:20:17.48,0:20:20.76,English,,0,0,0,,And all it does is it reads one character at a time
Dialogue: 0,0:20:17.48,0:20:20.76,Chinese,,0,0,0,,它所做的只是一次读取一个字符
Dialogue: 0,0:20:21.16,0:20:27.63,English,,0,0,0,,Looks for an end-of-file meaning that the input stream is closed or an end-of-line
Dialogue: 0,0:20:21.16,0:20:27.63,Chinese,,0,0,0,,查找文件结尾意味着输入流已关闭或行尾
Dialogue: 0,0:20:27.66,0:20:34.80,English,,0,0,0,,But as long as it until it sees that it just keeps adding more things to the end of this buffer
Dialogue: 0,0:20:27.66,0:20:34.80,Chinese,,0,0,0,,但只要它看到它只是不断添加更多的东西到这个缓冲区的末尾
Dialogue: 0,0:20:37.66,0:20:39.28,English,,0,0,0,,And so typically
Dialogue: 0,0:20:37.66,0:20:39.28,Chinese,,0,0,0,,通常如此
Dialogue: 0,0:20:43.98,0:20:50.66,English,,0,0,0,,When somebody calls gets they'll pass it a pointer to some buffer that they've allocated
Dialogue: 0,0:20:43.98,0:20:50.66,Chinese,,0,0,0,,当有人调用时，他们会向它传递一个指向他们已分配的缓冲区的指针
Dialogue: 0,0:20:51.36,0:20:56.00,English,,0,0,0,,But the function and it will just gets we'll just fill that buffer up
Dialogue: 0,0:20:51.36,0:20:56.00,Chinese,,0,0,0,,但是功能和它只会让我们只填充缓冲区
Dialogue: 0,0:20:56.80,0:21:00.76,English,,0,0,0,,But it can potentially just keep going there's nothing in the function
Dialogue: 0,0:20:56.80,0:21:00.76,Chinese,,0,0,0,,但它可能只是继续发挥作用
Dialogue: 0,0:21:00.96,0:21:03.44,English,,0,0,0,,There's not even an argument to the function
Dialogue: 0,0:21:00.96,0:21:03.44,Chinese,,0,0,0,,这个功能甚至没有争论
Dialogue: 0,0:21:03.90,0:21:10.26,English,,0,0,0,,That tells the function when it has to stop When it's reached the limit of it
Dialogue: 0,0:21:03.90,0:21:10.26,Chinese,,0,0,0,,这告诉函数何时必须停止它何时达到它的极限
Dialogue: 0,0:21:10.58,0:21:13.30,English,,0,0,0,,So it was written it actually gets is
Dialogue: 0,0:21:10.58,0:21:13.30,Chinese,,0,0,0,,所以写的它实际得到了
Dialogue: 0,0:21:13.30,0:21:17.62,English,,0,0,0,,If you try to compile code would gets it will flash up a big warning that says
Dialogue: 0,0:21:13.30,0:21:17.62,Chinese,,0,0,0,,如果你试图编译代码会得到它会闪现一个大警告说
Dialogue: 0,0:21:17.62,0:21:21.10,English,,0,0,0,,This is really an unsafe function you probably shouldn't even be using it
Dialogue: 0,0:21:17.62,0:21:21.10,Chinese,,0,0,0,,这实际上是一个不安全的功能，你甚至可能不应该使用它
Dialogue: 0,0:21:21.50,0:21:28.74,English,,0,0,0,,Because it was written in the 1970s
Dialogue: 0,0:21:21.50,0:21:28.74,Chinese,,0,0,0,,因为它写于20世纪70年代
Dialogue: 0,0:21:28.74,0:21:31.40,English,,0,0,0,,When the early UNIX distributions were coming out
Dialogue: 0,0:21:28.74,0:21:31.40,Chinese,,0,0,0,,当早期的UNIX发行版问世时
Dialogue: 0,0:21:31.76,0:21:34.60,English,,0,0,0,,Where people just weren't worried about security vulnerabilities
Dialogue: 0,0:21:31.76,0:21:34.60,Chinese,,0,0,0,,人们只是不担心安全漏洞
Dialogue: 0,0:21:34.78,0:21:40.94,English,,0,0,0,,And they just assumed that if you allocated a big enough buffer
Dialogue: 0,0:21:34.78,0:21:40.94,Chinese,,0,0,0,,他们只是假设你分配了足够大的缓冲区
Dialogue: 0,0:21:41.32,0:21:46.44,English,,0,0,0,,That there's no reason why a string should be bigger than what you've allocated
Dialogue: 0,0:21:41.32,0:21:46.44,Chinese,,0,0,0,,没有理由为什么字符串应该大于你分配的字符串
Dialogue: 0,0:21:47.90,0:21:53.16,English,,0,0,0,,And that's actually true with other functions like strcpy
Dialogue: 0,0:21:47.90,0:21:53.16,Chinese,,0,0,0,,对于像strcpy这样的其他函数来说，这实际上是正确的
Dialogue: 0,0:21:53.68,0:21:58.80,English,,0,0,0,,You recall strcpy has two arguments
Dialogue: 0,0:21:53.68,0:21:58.80,Chinese,,0,0,0,,你记得strcpy有两个参数
Dialogue: 0,0:21:59.40,0:22:02.86,English,,0,0,0,,Excuse me a destination and a source
Dialogue: 0,0:21:59.40,0:22:02.86,Chinese,,0,0,0,,对不起，目的地和来源
Dialogue: 0,0:22:03.78,0:22:08.64,English,,0,0,0,,And its purpose is to copy the string at the source into the destination
Dialogue: 0,0:22:03.78,0:22:08.64,Chinese,,0,0,0,,其目的是将源头处的字符串复制到目的地
Dialogue: 0,0:22:09.08,0:22:13.14,English,,0,0,0,,And the way it determines the end of the string and the source is when it hits a null character
Dialogue: 0,0:22:09.08,0:22:13.14,Chinese,,0,0,0,,它确定字符串结束的方式和源是它命中空字符的方式
Dialogue: 0,0:22:13.60,0:22:17.86,English,,0,0,0,,That just keeps copying one by one well until it hits it
Dialogue: 0,0:22:13.60,0:22:17.86,Chinese,,0,0,0,,这只是一个接一个地复制，直到它击中它
Dialogue: 0,0:22:18.10,0:22:22.38,English,,0,0,0,,But it has no way of knowing there's nothing no information there about how much
Dialogue: 0,0:22:18.10,0:22:22.38,Chinese,,0,0,0,,但它无法知道没有任何关于多少信息的信息
Dialogue: 0,0:22:22.76,0:22:27.38,English,,0,0,0,,How big is the the buffer allocated at the destination
Dialogue: 0,0:22:22.76,0:22:27.38,Chinese,,0,0,0,,在目的地分配的缓冲区有多大
Dialogue: 0,0:22:27.70,0:22:29.66,English,,0,0,0,,And so it can easily overrun that
Dialogue: 0,0:22:27.70,0:22:29.66,Chinese,,0,0,0,,所以它很容易超支
Dialogue: 0,0:22:29.92,0:22:36.66,English,,0,0,0,,That a similar one called strcat which is used to concatenate two strings copy another destination
Dialogue: 0,0:22:29.92,0:22:36.66,Chinese,,0,0,0,,类似的一个名为strcat，用于连接两个字符串复制另一个目标
Dialogue: 0,0:22:37.34,0:22:44.30,English,,0,0,0,,And the scanf functions also have possible in the format string
Dialogue: 0,0:22:37.34,0:22:44.30,Chinese,,0,0,0,,scanf函数也可以在格式字符串中使用
Dialogue: 0,0:22:44.30,0:22:46.06,English,,0,0,0,,You can give the %s
Dialogue: 0,0:22:44.30,0:22:46.06,Chinese,,0,0,0,,你可以给％s
Dialogue: 0,0:22:46.82,0:22:52.84,English,,0,0,0,,A directive to the format string which says read in a string and store it someplace
Dialogue: 0,0:22:46.82,0:22:52.84,Chinese,,0,0,0,,指向格式字符串的指令，该字符串表示读取字符串并将其存储在某个位置
Dialogue: 0,0:22:53.56,0:22:56.74,English,,0,0,0,,And it doesn't say how long the string is limited to be
Dialogue: 0,0:22:53.56,0:22:56.74,Chinese,,0,0,0,,并且它没有说明字符串被限制为多长时间
Dialogue: 0,0:22:56.74,0:23:00.52,English,,0,0,0,,And it doesn't say how much memory is available at the destination
Dialogue: 0,0:22:56.74,0:23:00.52,Chinese,,0,0,0,,并没有说目的地有多少内存可用
Dialogue: 0,0:23:00.78,0:23:04.52,English,,0,0,0,,So again it can easily just write over that a buffer
Dialogue: 0,0:23:00.78,0:23:04.52,Chinese,,0,0,0,,因此，它可以轻松地写入缓冲区
Dialogue: 0,0:23:05.72,0:23:10.84,English,,0,0,0,,So these are real vulnerabilities and they we'll talk in a minute a little later about
Dialogue: 0,0:23:05.72,0:23:10.84,Chinese,,0,0,0,,所以这些都是真正的漏洞，我们稍后会谈一会儿
Dialogue: 0,0:23:11.22,0:23:14.74,English,,0,0,0,,How you as a programmer can be a little smarter than this
Dialogue: 0,0:23:11.22,0:23:14.74,Chinese,,0,0,0,,作为一名程序员，你如何比这更聪明
Dialogue: 0,0:23:15.12,0:23:22.50,English,,0,0,0,,But in their suit of raw form as presented they have this vulnerability to them
Dialogue: 0,0:23:15.12,0:23:22.50,Chinese,,0,0,0,,但是在他们提出的原始形式的诉讼中，他们对他们有这种脆弱性
Dialogue: 0,0:23:23.68,0:23:29.30,English,,0,0,0,,So let's look at an example of what this can...what can happen there
Dialogue: 0,0:23:23.68,0:23:29.30,Chinese,,0,0,0,,那么让我们看一下这可以做什么的例子......那里会发生什么
Dialogue: 0,0:23:29.74,0:23:34.96,English,,0,0,0,,So imagine for example we want a to implement echo function
Dialogue: 0,0:23:29.74,0:23:34.96,Chinese,,0,0,0,,所以想象一下，例如我们想要实现echo函数
Dialogue: 0,0:23:34.96,0:23:40.02,English,,0,0,0,,So an echo function is one that you just type something in and prints it back out
Dialogue: 0,0:23:34.96,0:23:40.02,Chinese,,0,0,0,,因此，echo函数是你只需输入内容并将其打印出来的函数
Dialogue: 0,0:23:40.02,0:23:43.80,English,,0,0,0,,It's very uninteresting function except it's very useful to demonstrate things
Dialogue: 0,0:23:40.02,0:23:43.80,Chinese,,0,0,0,,这是非常无趣的功能，除了它展示事物非常有用
Dialogue: 0,0:23:44.58,0:23:49.32,English,,0,0,0,,So the idea is it has this little buffer it's only enough to hold four characters
Dialogue: 0,0:23:44.58,0:23:49.32,Chinese,,0,0,0,,所以这个想法是它有这个小缓冲区，它只能容纳四个字符
Dialogue: 0,0:23:49.78,0:23:55.44,English,,0,0,0,,Because get us to read a string from the input and then it calls puts
Dialogue: 0,0:23:49.78,0:23:55.44,Chinese,,0,0,0,,因为让我们从输入中读取一个字符串然后调用puts
Dialogue: 0,0:23:56.06,0:23:59.78,English,,0,0,0,,Which simply writes back out the output
Dialogue: 0,0:23:56.06,0:23:59.78,Chinese,,0,0,0,,这只是简单地写回输出
Dialogue: 0,0:24:00.80,0:24:01.58,English,,0,0,0,,And
Dialogue: 0,0:24:00.80,0:24:01.58,Chinese,,0,0,0,,和
Dialogue: 0,0:24:09.38,0:24:14.06,English,,0,0,0,,And so let me just demo this not very interesting function
Dialogue: 0,0:24:09.38,0:24:14.06,Chinese,,0,0,0,,所以让我演示这个不是很有趣的功能
Dialogue: 0,0:24:21.14,0:24:24.98,English,,0,0,0,,So I call here buffdemo-nsp
Dialogue: 0,0:24:21.14,0:24:24.98,Chinese,,0,0,0,,所以我在这里叫buffdemo-nsp
Dialogue: 0,0:24:26.74,0:24:31.04,English,,0,0,0,,Meaning as no stack protector we'll see in a minute what a stack protector is
Dialogue: 0,0:24:26.74,0:24:31.04,Chinese,,0,0,0,,意思是没有堆栈保护器我们会在一分钟内看到堆栈保护器是什么
Dialogue: 0,0:24:31.46,0:24:35.60,English,,0,0,0,,But you see if you type a reasonably strong small string
Dialogue: 0,0:24:31.46,0:24:35.60,Chinese,,0,0,0,,但是你看是否输入了一个相当强大的小字符串
Dialogue: 0,0:24:41.92,0:24:47.08,English,,0,0,0,,Let's see what remember it can handle more than four
Dialogue: 0,0:24:41.92,0:24:47.08,Chinese,,0,0,0,,让我们看看它能处理四个以上的东西
Dialogue: 0,0:24:48.04,0:24:50.98,English,,0,0,0,,Actually as written it can't handle more than three right
Dialogue: 0,0:24:48.04,0:24:50.98,Chinese,,0,0,0,,实际上，正如所写，它不能处理超过三个权利
Dialogue: 0,0:24:50.98,0:24:55.26,English,,0,0,0,,Because there should be room for the null character to on terminator
Dialogue: 0,0:24:50.98,0:24:55.26,Chinese,,0,0,0,,因为在终结符上应该有空字符的空间
Dialogue: 0,0:25:02.00,0:25:07.92,English,,0,0,0,,So it turns out with this particular one if I type in a string of 24 characters
Dialogue: 0,0:25:02.00,0:25:07.92,Chinese,,0,0,0,,因此，如果我输入一个包含24个字符的字符串，则会发现这个特定的一个
Dialogue: 0,0:25:09.72,0:25:11.04,English,,0,0,0,,It'll be okay
Dialogue: 0,0:25:09.72,0:25:11.04,Chinese,,0,0,0,,没关系
Dialogue: 0,0:25:22.36,0:25:24.86,English,,0,0,0,,But if I type in a string of 24 characters
Dialogue: 0,0:25:22.36,0:25:24.86,Chinese,,0,0,0,,但是如果我输入一个24个字符的字符串
Dialogue: 0,0:25:27.52,0:25:30.02,English,,0,0,0,,It will hit a segmentation fault
Dialogue: 0,0:25:27.52,0:25:30.02,Chinese,,0,0,0,,它会遇到分段错误
Dialogue: 0,0:25:33.12,0:25:35.90,English,,0,0,0,,So where do those numbers 23 and 24 come in
Dialogue: 0,0:25:33.12,0:25:35.90,Chinese,,0,0,0,,那么23号和24号的位置在哪里呢？
Dialogue: 0,0:25:35.90,0:25:39.04,English,,0,0,0,,Well that's something we can learn by looking at the assembly code
Dialogue: 0,0:25:35.90,0:25:39.04,Chinese,,0,0,0,,那么我们可以通过查看汇编代码来学习
Dialogue: 0,0:25:56.22,0:25:59.18,English,,0,0,0,,So here's and we'll go through this code
Dialogue: 0,0:25:56.22,0:25:59.18,Chinese,,0,0,0,,所以这里，我们将通过这段代码
Dialogue: 0,0:26:00.08,0:26:04.70,English,,0,0,0,,So first of all, this is the code for echo then
Dialogue: 0,0:26:00.08,0:26:04.70,Chinese,,0,0,0,,首先，这是echo的代码
Dialogue: 0,0:26:05.58,0:26:09.18,English,,0,0,0,,And you see the echo calls gets and it calls puts
Dialogue: 0,0:26:05.58,0:26:09.18,Chinese,,0,0,0,,你看到echo调用得到它并调用puts
Dialogue: 0,0:26:13.34,0:26:19.56,English,,0,0,0,,And here's the part of the code where you can tell how much memory got allocated for the buffer
Dialogue: 0,0:26:13.34,0:26:19.56,Chinese,,0,0,0,,这里是代码的一部分，你可以告诉我们为缓冲区分配了多少内存
Dialogue: 0,0:26:20.06,0:26:29.34,English,,0,0,0,,And 0x18 is what in decimal
Dialogue: 0,0:26:20.06,0:26:29.34,Chinese,,0,0,0,,而0x18是十进制的
Dialogue: 0,0:26:34.04,0:26:34.98,English,,0,0,0,,24 right?
Dialogue: 0,0:26:34.04,0:26:34.98,Chinese,,0,0,0,,24对吗？
Dialogue: 0,0:26:39.64,0:26:45.54,English,,0,0,0,,And just saw that the thing actually segfaults with a input string of 24
Dialogue: 0,0:26:39.64,0:26:45.54,Chinese,,0,0,0,,只是看到这个东西实际上是一个输入字符串为24的段错误
Dialogue: 0,0:26:45.54,0:26:46.60,English,,0,0,0,,So we'll see that in a minute
Dialogue: 0,0:26:45.54,0:26:46.60,Chinese,,0,0,0,,所以我们会在一分钟内看到
Dialogue: 0,0:26:47.50,0:26:55.28,English,,0,0,0,,But anyways you can see here that it's allocating on the stack a region of 24 bytes
Dialogue: 0,0:26:47.50,0:26:55.28,Chinese,,0,0,0,,但无论如何你可以在这里看到它在堆栈上分配一个24字节的区域
Dialogue: 0,0:26:56.00,0:27:04.14,English,,0,0,0,,And it's copying that into %rdi which is of course the argument for gets
Dialogue: 0,0:26:56.00,0:27:04.14,Chinese,,0,0,0,,它正在将其复制到％rdi中，这当然是获取的参数
Dialogue: 0,0:27:04.20,0:27:12.76,English,,0,0,0,,So gets is being called with a pointer to a buffer of size 24 of maximum 24
Dialogue: 0,0:27:04.20,0:27:12.76,Chinese,,0,0,0,,因此，使用指向最大24的大小为24的缓冲区的指针调用gets
Dialogue: 0,0:27:12.80,0:27:16.62,English,,0,0,0,,Or even though you saw the original declaration was just four
Dialogue: 0,0:27:12.80,0:27:16.62,Chinese,,0,0,0,,或者即使你看到原始声明只有四个
Dialogue: 0,0:27:20.20,0:27:25.84,English,,0,0,0,,Um and then it calls gets and then gets does it thing
Dialogue: 0,0:27:20.20,0:27:25.84,Chinese,,0,0,0,,嗯然后它调用得到然后得到它做的事情
Dialogue: 0,0:27:26.44,0:27:30.10,English,,0,0,0,,And just one last little bit to keep in mind is
Dialogue: 0,0:27:26.44,0:27:30.10,Chinese,,0,0,0,,最后一点要记住的是
Dialogue: 0,0:27:31.16,0:27:32.72,English,,0,0,0,,We'll get back to them
Dialogue: 0,0:27:31.16,0:27:32.72,Chinese,,0,0,0,,我们会回复他们
Dialogue: 0,0:27:33.14,0:27:36.10,English,,0,0,0,,Oh yes and remember echo
Dialogue: 0,0:27:33.14,0:27:36.10,Chinese,,0,0,0,,哦，是的，记得回声
Dialogue: 0,0:27:38.36,0:27:42.74,English,,0,0,0,,I there's a function called call_echo which is the thing that calls echo
Dialogue: 0,0:27:38.36,0:27:42.74,Chinese,,0,0,0,,我有一个名为call_echo的函数，它调用echo
Dialogue: 0,0:27:43.46,0:27:48.84,English,,0,0,0,,And just to keep in mind this red is the return address  for call_echo
Dialogue: 0,0:27:43.46,0:27:48.84,Chinese,,0,0,0,,并且要记住这个红色是call_echo的返回地址
Dialogue: 0,0:27:49.94,0:27:51.88,English,,0,0,0,,And that's going to be important
Dialogue: 0,0:27:49.94,0:27:51.88,Chinese,,0,0,0,,这将是重要的
Dialogue: 0,0:27:55.94,0:27:59.66,English,,0,0,0,,So what we see then is the memory layout is
Dialogue: 0,0:27:55.94,0:27:59.66,Chinese,,0,0,0,,所以我们看到的是内存布局
Dialogue: 0,0:28:01.22,0:28:05.86,English,,0,0,0,,The buff is normally big enough for four characters
Dialogue: 0,0:28:01.22,0:28:05.86,Chinese,,0,0,0,,buff通常足以容纳四个字符
Dialogue: 0,0:28:06.58,0:28:10.60,English,,0,0,0,,There's a sort of 20 bytes of unused or wasted space here
Dialogue: 0,0:28:06.58,0:28:10.60,Chinese,,0,0,0,,这里有20个字节的未使用或浪费的空间
Dialogue: 0,0:28:10.96,0:28:17.86,English,,0,0,0,,And then the actual return address which is the return address for back to call_echo is stored on the stack
Dialogue: 0,0:28:10.96,0:28:17.86,Chinese,,0,0,0,,然后将实际返回地址（返回call_echo的返回地址）存储在堆栈中
Dialogue: 0,0:28:23.56,0:28:28.80,English,,0,0,0,,So when this program begins running when echo starts to run
Dialogue: 0,0:28:23.56,0:28:28.80,Chinese,,0,0,0,,所以当这个程序开始运行时，echo开始运行
Dialogue: 0,0:28:29.12,0:28:34.38,English,,0,0,0,,We'll find that this is the value on the stack for the return pointer
Dialogue: 0,0:28:29.12,0:28:34.38,Chinese,,0,0,0,,我们会发现这是返回指针的堆栈值
Dialogue: 0,0:28:35.98,0:28:43.04,English,,0,0,0,,And if we type in a string of up here of 23 characters
Dialogue: 0,0:28:35.98,0:28:43.04,Chinese,,0,0,0,,如果我们输入一个23个字符的字符串
Dialogue: 0,0:28:43.88,0:28:50.22,English,,0,0,0,,You'll see that it uses up this entire buffer and remember a string is terminated with 00
Dialogue: 0,0:28:43.88,0:28:50.22,Chinese,,0,0,0,,你会看到它耗尽了整个缓冲区并记住字符串以00结尾
Dialogue: 0,0:28:51.10,0:28:57.40,English,,0,0,0,,But it still hasn't...it's still within the region that was allocated on the stack for that
Dialogue: 0,0:28:51.10,0:28:57.40,Chinese,,0,0,0,,但它仍然没有...它仍然在为堆栈分配的区域内
Dialogue: 0,0:28:57.48,0:29:01.60,English,,0,0,0,,So it just barely fits into the the stack
Dialogue: 0,0:28:57.48,0:29:01.60,Chinese,,0,0,0,,所以它几乎不适合堆栈
Dialogue: 0,0:29:02.18,0:29:06.20,English,,0,0,0,,And that's why we technically we overflowed the buffer
Dialogue: 0,0:29:02.18,0:29:06.20,Chinese,,0,0,0,,这就是为什么我们在技术上会溢出缓冲区
Dialogue: 0,0:29:06.20,0:29:10.40,English,,0,0,0,,But we didn't really cause any harm because there was this extra space available
Dialogue: 0,0:29:06.20,0:29:10.40,Chinese,,0,0,0,,但是我们并没有真正造成任何伤害，因为有这个额外的空间可用
Dialogue: 0,0:29:11.38,0:29:17.96,English,,0,0,0,,And so that's why I could type in that string of 23 characters and it worked fine
Dialogue: 0,0:29:11.38,0:29:17.96,Chinese,,0,0,0,,这就是为什么我可以键入23个字符的字符串，它工作正常
Dialogue: 0,0:29:18.98,0:29:20.36,English,,0,0,0,,But now if I type in...
Dialogue: 0,0:29:18.98,0:29:20.36,Chinese,,0,0,0,,但现在如果我输入...
Dialogue: 0,0:29:21.76,0:29:23.92,English,,0,0,0,,This is an example showing...
Dialogue: 0,0:29:21.76,0:29:23.92,Chinese,,0,0,0,,这是一个显示......的例子
Dialogue: 0,0:29:29.44,0:29:31.12,English,,0,0,0,,I actually 25 characters
Dialogue: 0,0:29:29.44,0:29:31.12,Chinese,,0,0,0,,我实际上是25个字符
Dialogue: 0,0:29:32.74,0:29:40.14,English,,0,0,0,,So once I go beyond the 23 characters plus the null character you'll see
Dialogue: 0,0:29:32.74,0:29:40.14,Chinese,,0,0,0,,所以，一旦我超越了23个字符加上你将看到的空字符
Dialogue: 0,0:29:40.14,0:29:49.72,English,,0,0,0,,what I'm slowly starting to do is corrupt the the the byte representation of the return address
Dialogue: 0,0:29:40.14,0:29:49.72,Chinese,,0,0,0,,我正在慢慢开始做的是破坏返回地址的字节表示
Dialogue: 0,0:29:50.38,0:29:52.64,English,,0,0,0,,And so what happens for example here
Dialogue: 0,0:29:50.38,0:29:52.64,Chinese,,0,0,0,,所以这里发生了什么
Dialogue: 0,0:29:53.00,0:30:00.98,English,,0,0,0,,Is that rather than trying to return back to the where call_echo was supposed to where it was supposed to go back to
Dialogue: 0,0:29:53.00,0:30:00.98,Chinese,,0,0,0,,是不是试图回到call_echo所应该回到的地方
Dialogue: 0,0:30:01.32,0:30:03.74,English,,0,0,0,,It goes back to some other part of your code
Dialogue: 0,0:30:01.32,0:30:03.74,Chinese,,0,0,0,,它可以追溯到代码的其他部分
Dialogue: 0,0:30:04.20,0:30:08.08,English,,0,0,0,,That may or may not be a valid address or
Dialogue: 0,0:30:04.20,0:30:08.08,Chinese,,0,0,0,,这可能是也可能不是有效的地址或
Dialogue: 0,0:30:08.22,0:30:11.00,English,,0,0,0,,Might not have anything to do with the program you're trying to run
Dialogue: 0,0:30:08.22,0:30:11.00,Chinese,,0,0,0,,可能与你尝试运行的程序无关
Dialogue: 0,0:30:12.56,0:30:16.56,English,,0,0,0,,So this example shows it and if I typed in the 24
Dialogue: 0,0:30:12.56,0:30:16.56,Chinese,,0,0,0,,所以这个例子显示了它，如果我输入24
Dialogue: 0,0:30:22.10,0:30:26.04,English,,0,0,0,,Let's see...before I got it to run
Dialogue: 0,0:30:22.10,0:30:26.04,Chinese,,0,0,0,,在我开始运行之前，让我们看看......
Dialogue: 0,0:30:26.04,0:30:29.94,English,,0,0,0,,Like this you know this thing depends on the what happens
Dialogue: 0,0:30:26.04,0:30:29.94,Chinese,,0,0,0,,像这样你知道这件事取决于发生了什么
Dialogue: 0,0:30:31.04,0:30:33.48,English,,0,0,0,,How the code happens to get compiled
Dialogue: 0,0:30:31.04,0:30:33.48,Chinese,,0,0,0,,如何编译代码
Dialogue: 0,0:30:36.04,0:30:42.70,English,,0,0,0,,Oh yeah so okay, so actually you see here
Dialogue: 0,0:30:36.04,0:30:42.70,Chinese,,0,0,0,,哦，是的，所以你真的看到了这里
Dialogue: 0,0:30:43.90,0:30:49.12,English,,0,0,0,,This first string I typed is actually 24 characters long plus the null pointer
Dialogue: 0,0:30:43.90,0:30:49.12,Chinese,,0,0,0,,我输入的第一个字符串实际上是24个字符加上空指针
Dialogue: 0,0:30:49.80,0:30:54.12,English,,0,0,0,,So uh and we'll see why it didn't...it should have crashed
Dialogue: 0,0:30:49.80,0:30:54.12,Chinese,,0,0,0,,所以呃，我们会明白为什么它没有......它应该崩溃了
Dialogue: 0,0:30:54.38,0:30:58.86,English,,0,0,0,,Because we actually overwrite wrote the low order byte of the return address
Dialogue: 0,0:30:54.38,0:30:58.86,Chinese,,0,0,0,,因为我们实际上覆盖了写入返回地址的低位字节
Dialogue: 0,0:30:59.68,0:31:02.10,English,,0,0,0,,Here we typed in this is 25 characters
Dialogue: 0,0:30:59.68,0:31:02.10,Chinese,,0,0,0,,这里我们输入的是25个字符
Dialogue: 0,0:31:02.10,0:31:07.46,English,,0,0,0,,And so that's the one I just showed where it really whacked the two bytes of the return address
Dialogue: 0,0:31:02.10,0:31:07.46,Chinese,,0,0,0,,这就是我刚才展示的那个它真正打击了返回地址的两个字节的地方
Dialogue: 0,0:31:08.02,0:31:10.22,English,,0,0,0,,So here we actually did overflow the buffer
Dialogue: 0,0:31:08.02,0:31:10.22,Chinese,,0,0,0,,所以这里我们确实溢出了缓冲区
Dialogue: 0,0:31:11.24,0:31:17.22,English,,0,0,0,,And let's try and figure out why that didn't harm the the program execution
Dialogue: 0,0:31:11.24,0:31:17.22,Chinese,,0,0,0,,让我们试着弄清楚为什么这不会损害程序的执行
Dialogue: 0,0:31:17.22,0:31:18.20,English,,0,0,0,,I see a question
Dialogue: 0,0:31:17.22,0:31:18.20,Chinese,,0,0,0,,我看到一个问题
Dialogue: 0,0:31:18.20,0:31:22.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:18.20,0:31:22.78,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:31:22.78,0:31:25.58,English,,0,0,0,,Yes it could have been various other things could have there's nothing
Dialogue: 0,0:31:22.78,0:31:25.58,Chinese,,0,0,0,,是的它可能是其他各种事情可能没有什么
Dialogue: 0,0:31:26.26,0:31:28.68,English,,0,0,0,,It hit a segmentation fault
Dialogue: 0,0:31:26.26,0:31:28.68,Chinese,,0,0,0,,它遇到了分段错误
Dialogue: 0,0:31:28.98,0:31:33.14,English,,0,0,0,,It probably went to some weird part of the code and just started executing some random stuff
Dialogue: 0,0:31:28.98,0:31:33.14,Chinese,,0,0,0,,它可能去了一些奇怪的代码部分，并开始执行一些随机的东西
Dialogue: 0,0:31:33.48,0:31:35.14,English,,0,0,0,,And just got itself into trouble
Dialogue: 0,0:31:33.48,0:31:35.14,Chinese,,0,0,0,,然后就陷入了麻烦
Dialogue: 0,0:31:35.58,0:31:40.48,English,,0,0,0,,But that's the point is it's not predictable exactly what will happen when you do this
Dialogue: 0,0:31:35.58,0:31:40.48,Chinese,,0,0,0,,但重点是，当你这样做时，确切地说会发生什么是不可预测的
Dialogue: 0,0:31:52.40,0:31:56.10,English,,0,0,0,,So this is that the example of what actually happened the first time
Dialogue: 0,0:31:52.40,0:31:56.10,Chinese,,0,0,0,,所以这就是第一次实际发生的事例
Dialogue: 0,0:31:56.42,0:31:59.84,English,,0,0,0,,When I typed in a string that had 24 characters
Dialogue: 0,0:31:56.42,0:31:59.84,Chinese,,0,0,0,,当我输入一个包含24个字符的字符串时
Dialogue: 0,0:32:00.24,0:32:04.02,English,,0,0,0,,And so this null byte at the end actually corrupted the return address
Dialogue: 0,0:32:00.24,0:32:04.02,Chinese,,0,0,0,,所以最后这个空字节实际上破坏了返回地址
Dialogue: 0,0:32:05.68,0:32:12.30,English,,0,0,0,,And so it was supposed to return back to this address 0x4006f6
Dialogue: 0,0:32:05.68,0:32:12.30,Chinese,,0,0,0,,所以它应该返回到这个地址0x4006f6
Dialogue: 0,0:32:12.92,0:32:16.98,English,,0,0,0,,And instead it will return back to the address 0x400600
Dialogue: 0,0:32:12.92,0:32:16.98,Chinese,,0,0,0,,而它将返回到地址0x400600
Dialogue: 0,0:32:18.04,0:32:21.64,English,,0,0,0,,Which happens to be in some other weird function that's there
Dialogue: 0,0:32:18.04,0:32:21.64,Chinese,,0,0,0,,这恰好出现在其他一些奇怪的功能中
Dialogue: 0,0:32:21.94,0:32:26.16,English,,0,0,0,,And it just sort of landed at some place here
Dialogue: 0,0:32:21.94,0:32:26.16,Chinese,,0,0,0,,它只是落在这里的某个地方
Dialogue: 0,0:32:26.16,0:32:33.28,English,,0,0,0,,And it's doing various things but somehow it didn't really (didn't) crash the program
Dialogue: 0,0:32:26.16,0:32:33.28,Chinese,,0,0,0,,它正在做各种各样的事情，但不知何故，它并没有真正（没有）使程序崩溃
Dialogue: 0,0:32:33.28,0:32:38.62,English,,0,0,0,,And that's one of the frustrating things about this is that things can go wrong in a program
Dialogue: 0,0:32:33.28,0:32:38.62,Chinese,,0,0,0,,而这令人沮丧的事情之一是，程序中的事情可能会出错
Dialogue: 0,0:32:39.12,0:32:41.80,English,,0,0,0,,And they don't always cause a crash
Dialogue: 0,0:32:39.12,0:32:41.80,Chinese,,0,0,0,,而且他们并不总是导致崩溃
Dialogue: 0,0:32:42.14,0:32:47.36,English,,0,0,0,,And so often a bug that's working there might be doing some weird stuff that you don't even know about
Dialogue: 0,0:32:42.14,0:32:47.36,Chinese,,0,0,0,,因此，经常在那里工作的bug可能会做一些你甚至不知道的奇怪的东西
Dialogue: 0,0:32:51.44,0:32:56.90,English,,0,0,0,,So that's all a fine if it's just a way of crashing programs and
Dialogue: 0,0:32:51.44,0:32:56.90,Chinese,,0,0,0,,如果它只是一种崩溃程序的方式，那就没关系了
Dialogue: 0,0:32:57.26,0:33:01.54,English,,0,0,0,,I mean that's not great if it's controlling your pacemaker or something like that
Dialogue: 0,0:32:57.26,0:33:01.54,Chinese,,0,0,0,,我的意思是，如果它控制你的心脏起搏器或类似的东西，那就不好了
Dialogue: 0,0:33:01.54,0:33:08.42,English,,0,0,0,,But if it's just a homework assignment it's like not a big deal so
Dialogue: 0,0:33:01.54,0:33:08.42,Chinese,,0,0,0,,但如果它只是一个家庭作业，那就不是什么大不了的事了
Dialogue: 0,0:33:10.46,0:33:15.78,English,,0,0,0,,But what actually and this is sort of only happened since
Dialogue: 0,0:33:10.46,0:33:15.78,Chinese,,0,0,0,,但事实上，这种情况只发生在那之后
Dialogue: 0,0:33:16.00,0:33:22.22,English,,0,0,0,,Attacking became a normal activity which has only been the last 30 years
Dialogue: 0,0:33:16.00,0:33:22.22,Chinese,,0,0,0,,攻击成为一种正常活动，仅仅是过去30年
Dialogue: 0,0:33:22.62,0:33:32.48,English,,0,0,0,,Is that it gives an opportunity for a hacker or a attacker to inject code into the program and execute it
Dialogue: 0,0:33:22.62,0:33:32.48,Chinese,,0,0,0,,是否为黑客或攻击者提供了将代码注入程序并执行它的机会
Dialogue: 0,0:33:32.48,0:33:35.52,English,,0,0,0,,And that's what's called a code injection attack
Dialogue: 0,0:33:32.48,0:33:35.52,Chinese,,0,0,0,,这就是所谓的代码注入攻击
Dialogue: 0,0:33:36.34,0:33:43.18,English,,0,0,0,,And so that the general scheme of it is I have this buffer that I can fill up with whatever bytes I want
Dialogue: 0,0:33:36.34,0:33:43.18,Chinese,,0,0,0,,因此，它的一般方案是我有这个缓冲区，我可以填写我想要的任何字节
Dialogue: 0,0:33:43.52,0:33:47.68,English,,0,0,0,,By feeding them to gets or whatever function is doing this copying
Dialogue: 0,0:33:43.52,0:33:47.68,Chinese,,0,0,0,,通过喂他们获取或任何功能正在进行此复制
Dialogue: 0,0:33:48.00,0:33:51.36,English,,0,0,0,,And what I can do then is set up and pass to it
Dialogue: 0,0:33:48.00,0:33:51.36,Chinese,,0,0,0,,然后我可以做的就是设置并传递给它
Dialogue: 0,0:33:51.46,0:33:57.48,English,,0,0,0,,Some bytes of actually that encode an executable a little bit of executable code
Dialogue: 0,0:33:51.46,0:33:57.48,Chinese,,0,0,0,,实际上有些字节可编码可执行代码的一些可执行代码
Dialogue: 0,0:33:57.48,0:34:03.32,English,,0,0,0,,You've seen an object dump it's printing out these byte code representations of instructions
Dialogue: 0,0:33:57.48,0:34:03.32,Chinese,,0,0,0,,你已经看到了一个对象转储，它打印出这些指令的字节代码表示
Dialogue: 0,0:34:03.32,0:34:09.24,English,,0,0,0,,So imagine you fed some of those bytes into your string
Dialogue: 0,0:34:03.32,0:34:09.24,Chinese,,0,0,0,,所以想象一下，你把这些字节中的一些输入到字符串中
Dialogue: 0,0:34:09.26,0:34:11.90,English,,0,0,0,,You encoded them in the string that you pass to gets
Dialogue: 0,0:34:09.26,0:34:11.90,Chinese,,0,0,0,,你在传递给它的字符串中对它们进行了编码
Dialogue: 0,0:34:13.04,0:34:22.56,English,,0,0,0,,And then you might have to add some more sort of padding characters ,that characters whose value doesn't matter
Dialogue: 0,0:34:13.04,0:34:22.56,Chinese,,0,0,0,,然后你可能需要添加更多类型的填充字符，这些字符的值无关紧要
Dialogue: 0,0:34:23.03,0:34:30.14,English,,0,0,0,,In order to then get a number back into the position where the return pointer is supposed to be
Dialogue: 0,0:34:23.03,0:34:30.14,Chinese,,0,0,0,,然后将数字返回到返回指针所在的位置
Dialogue: 0,0:34:30.64,0:34:33.76,English,,0,0,0,,And so what's call that number B,it's going to be an address
Dialogue: 0,0:34:30.64,0:34:33.76,Chinese,,0,0,0,,所以叫做B号，它就是一个地址
Dialogue: 0,0:34:34.20,0:34:39.22,English,,0,0,0,,One of these ones with the you know that represents a stack location
Dialogue: 0,0:34:34.20,0:34:39.22,Chinese,,0,0,0,,其中一个与你知道代表堆栈位置的那些
Dialogue: 0,0:34:39.58,0:34:44.24,English,,0,0,0,,And that value B that is the the starting address of the buffer
Dialogue: 0,0:34:39.58,0:34:44.24,Chinese,,0,0,0,,而那个值B是缓冲区的起始地址
Dialogue: 0,0:34:44.72,0:34:53.20,English,,0,0,0,,Which happens to be where your exploit code remember this is just executable instructions or stored here
Dialogue: 0,0:34:44.72,0:34:53.20,Chinese,,0,0,0,,这恰好是你的漏洞利用代码记住这只是可执行指令或存储在此处的地方
Dialogue: 0,0:34:53.78,0:35:00.46,English,,0,0,0,,So now what will happen is when the program does its return here
Dialogue: 0,0:34:53.78,0:35:00.46,Chinese,,0,0,0,,所以现在将会发生什么，当程序在这里返回时
Dialogue: 0,0:35:01.54,0:35:06.12,English,,0,0,0,,It was supposed to return back to wherever it got called from P
Dialogue: 0,0:35:01.54,0:35:06.12,Chinese,,0,0,0,,它应该回到从P调用的任何地方
Dialogue: 0,0:35:11.18,0:35:14.58,English,,0,0,0,,This is a typo, P calls Q not the bar
Dialogue: 0,0:35:11.18,0:35:14.58,Chinese,,0,0,0,,这是一个错字，P称Q不是吧
Dialogue: 0,0:35:18.25,0:35:20.62,English,,0,0,0,,So it's supposed to return back to P
Dialogue: 0,0:35:18.25,0:35:20.62,Chinese,,0,0,0,,所以它应该回到P
Dialogue: 0,0:35:21.46,0:35:26.66,English,,0,0,0,,And we're and the address the return address was stored here
Dialogue: 0,0:35:21.46,0:35:26.66,Chinese,,0,0,0,,我们和返回地址的地址都存储在这里
Dialogue: 0,0:35:26.66,0:35:31.54,English,,0,0,0,,But now I've overwritten that return address  with this buffer position
Dialogue: 0,0:35:26.66,0:35:31.54,Chinese,,0,0,0,,但现在我用这个缓冲区位置覆盖了该返回地址
Dialogue: 0,0:35:31.54,0:35:37.40,English,,0,0,0,,So what will happen is the the program counter will happily jump to this bar
Dialogue: 0,0:35:31.54,0:35:37.40,Chinese,,0,0,0,,所以会发生什么是程序计数器会愉快地跳到这个栏
Dialogue: 0,0:35:37.40,0:35:43.04,English,,0,0,0,,And start executing whatever it encounters which are the instructions that you've inserted
Dialogue: 0,0:35:37.40,0:35:43.04,Chinese,,0,0,0,,并开始执行它遇到的任何内容，这些是你插入的指令
Dialogue: 0,0:35:43.70,0:35:51.70,English,,0,0,0,,And by that means then you can inject code into a machine potentially Somewhere else in the internet
Dialogue: 0,0:35:43.70,0:35:51.70,Chinese,,0,0,0,,通过这种方式，你可以将代码注入到可能位于互联网其他地方的计算机中
Dialogue: 0,0:35:51.70,0:35:53.72,English,,0,0,0,,If you could set up a scheme like this
Dialogue: 0,0:35:51.70,0:35:53.72,Chinese,,0,0,0,,如果你可以设置这样的方案
Dialogue: 0,0:35:53.72,0:35:58.28,English,,0,0,0,,That would feed these bytes into that machine
Dialogue: 0,0:35:53.72,0:35:58.28,Chinese,,0,0,0,,这会将这些字节输入该机器
Dialogue: 0,0:35:58.54,0:36:01.06,English,,0,0,0,,And it would read it in with a function like gets
Dialogue: 0,0:35:58.54,0:36:01.06,Chinese,,0,0,0,,并且它会使用像gets这样的函数来读取它
Dialogue: 0,0:36:01.44,0:36:05.28,English,,0,0,0,,And then it would try to do its return but it would start executing your code
Dialogue: 0,0:36:01.44,0:36:05.28,Chinese,,0,0,0,,然后它会尝试返回但它会开始执行你的代码
Dialogue: 0,0:36:06.22,0:36:09.24,English,,0,0,0,,So that's a classic code injection attack
Dialogue: 0,0:36:06.22,0:36:09.24,Chinese,,0,0,0,,这是一个典型的代码注入攻击
Dialogue: 0,0:36:09.54,0:36:14.36,English,,0,0,0,,And in fact in this lab that you're going to start,comes out at midnight
Dialogue: 0,0:36:09.54,0:36:14.36,Chinese,,0,0,0,,事实上，在你即将开始的这个实验室中，午夜时分出来
Dialogue: 0,0:36:14.68,0:36:24.50,English,,0,0,0,,It's called the attack lab because you're going to do this yourself for part of the lab
Dialogue: 0,0:36:14.68,0:36:24.50,Chinese,,0,0,0,,它被称为攻击实验室，因为你将自己为实验室的一部分做这件事
Dialogue: 0,0:36:25.06,0:36:26.80,English,,0,0,0,,I think you'll find it pretty interesting
Dialogue: 0,0:36:25.06,0:36:26.80,Chinese,,0,0,0,,我想你会发现它非常有趣
Dialogue: 0,0:36:31.64,0:36:35.20,English,,0,0,0,,So this used to be a huge problem on programs
Dialogue: 0,0:36:31.64,0:36:35.20,Chinese,,0,0,0,,所以这曾经是程序上的一个大问题
Dialogue: 0,0:36:35.20,0:36:46.44,English,,0,0,0,,-yes-so when you're trying to replace read how do you make sure that your new submitted read provides that exact line
Dialogue: 0,0:36:35.20,0:36:46.44,Chinese,,0,0,0,,-yes-所以当你试图替换读取时如何确保新提交的读取提供了确切的行
Dialogue: 0,0:36:46.46,0:36:49.04,English,,0,0,0,,Well that's part of the cleverness of being a hacker
Dialogue: 0,0:36:46.46,0:36:49.04,Chinese,,0,0,0,,那就是成为黑客的聪明之处
Dialogue: 0,0:36:49.70,0:36:51.92,English,,0,0,0,,You have to make sure it's in the right spot
Dialogue: 0,0:36:49.70,0:36:51.92,Chinese,,0,0,0,,你必须确保它在正确的位置
Dialogue: 0,0:36:51.92,0:36:54.40,English,,0,0,0,,But it's that's actually one of the easier parts
Dialogue: 0,0:36:51.92,0:36:54.40,Chinese,,0,0,0,,但它实际上是更容易的部分之一
Dialogue: 0,0:36:54.98,0:37:03.72,English,,0,0,0,,Because for example you have to know the binary code To be able to do this or be able to guess
Dialogue: 0,0:36:54.98,0:37:03.72,Chinese,,0,0,0,,因为例如你必须知道二进制代码才能做到这一点或能够猜测
Dialogue: 0,0:37:04.44,0:37:09.44,English,,0,0,0,,So for example in that previous one I could tell that it was allocating 24 bytes for that buffer
Dialogue: 0,0:37:04.44,0:37:09.44,Chinese,,0,0,0,,所以例如在前一个我可以告诉它为该缓冲区分配24个字节
Dialogue: 0,0:37:10.20,0:37:15.58,English,,0,0,0,,And so if I just made sure that the length of my exploit code plus the padding is 24 bytes
Dialogue: 0,0:37:10.20,0:37:15.58,Chinese,,0,0,0,,因此，如果我确保我的漏洞利用代码的长度加上填充是24字节
Dialogue: 0,0:37:16.30,0:37:18.96,English,,0,0,0,,Then right after that comes the return address
Dialogue: 0,0:37:16.30,0:37:18.96,Chinese,,0,0,0,,然后就在那之后返回地址
Dialogue: 0,0:37:18.96,0:37:20.60,English,,0,0,0,,So that's actually pretty easy to do
Dialogue: 0,0:37:18.96,0:37:20.60,Chinese,,0,0,0,,所以这实际上很容易做到
Dialogue: 0,0:37:20.60,0:37:22.80,English,,0,0,0,,There was certainly how much memory program is that
Dialogue: 0,0:37:20.60,0:37:22.80,Chinese,,0,0,0,,肯定有多少内存程序
Dialogue: 0,0:37:22.80,0:37:29.72,English,,0,0,0,,No you have to have access,you have to know what the reason why this works is
Dialogue: 0,0:37:22.80,0:37:29.72,Chinese,,0,0,0,,不，你必须有访问权限，你必须知道它的工作原因是什么
Dialogue: 0,0:37:30.84,0:37:35.90,English,,0,0,0,,It works if you have enough knowledge about the operating system that's running at the other end
Dialogue: 0,0:37:30.84,0:37:35.90,Chinese,,0,0,0,,如果你对在另一端运行的操作系统有足够的了解，它就可以工作
Dialogue: 0,0:37:36.30,0:37:37.84,English,,0,0,0,,For example you know it's Linux
Dialogue: 0,0:37:36.30,0:37:37.84,Chinese,,0,0,0,,例如，你知道它是Linux
Dialogue: 0,0:37:38.18,0:37:44.10,English,,0,0,0,,You know that you can look at you know what GCC tends to allocate for
Dialogue: 0,0:37:38.18,0:37:44.10,Chinese,,0,0,0,,你知道你可以看看你知道GCC倾向于分配什么
Dialogue: 0,0:37:44.10,0:37:47.40,English,,0,0,0,,It you somehow have access to information about the code itself
Dialogue: 0,0:37:44.10,0:37:47.40,Chinese,,0,0,0,,它以某种方式可以访问有关代码本身的信息
Dialogue: 0,0:37:48.18,0:37:50.14,English,,0,0,0,,Let's you do this
Dialogue: 0,0:37:48.18,0:37:50.14,Chinese,,0,0,0,,我们你这样做
Dialogue: 0,0:37:56.48,0:37:59.14,English,,0,0,0,,Oh so anyways this used to be a huge problem
Dialogue: 0,0:37:56.48,0:37:59.14,Chinese,,0,0,0,,哦，所以无论如何这曾经是一个巨大的问题
Dialogue: 0,0:37:59.16,0:38:05.32,English,,0,0,0,,And it started way back in 1988 the first internet attack with called the Morris worm
Dialogue: 0,0:37:59.16,0:38:05.32,Chinese,,0,0,0,,它始于1988年第一次被称为莫里斯蠕虫的互联网攻击
Dialogue: 0,0:38:05.86,0:38:10.24,English,,0,0,0,,And it at the time the internet was not a very big place
Dialogue: 0,0:38:05.86,0:38:10.24,Chinese,,0,0,0,,当时互联网并不是一个非常大的地方
Dialogue: 0,0:38:11.16,0:38:14.08,English,,0,0,0,,And it basically brought down a huge fraction of the machines
Dialogue: 0,0:38:11.16,0:38:14.08,Chinese,,0,0,0,,它基本上耗尽了很大一部分机器
Dialogue: 0,0:38:14.48,0:38:17.00,English,,0,0,0,,That were on the internet at the time
Dialogue: 0,0:38:14.48,0:38:17.00,Chinese,,0,0,0,,那是当时的互联网
Dialogue: 0,0:38:17.00,0:38:22.18,English,,0,0,0,,Interestingly enough CMU did not fall victim to this attack
Dialogue: 0,0:38:17.00,0:38:22.18,Chinese,,0,0,0,,有趣的是，CMU并没有成为这次袭击的牺牲品
Dialogue: 0,0:38:22.18,0:38:28.48,English,,0,0,0,,Because we'd patched already the vulnerabilities that this particular program exploited
Dialogue: 0,0:38:22.18,0:38:28.48,Chinese,,0,0,0,,因为我们已经修补了这个特定程序利用的漏洞
Dialogue: 0,0:38:32.22,0:38:39.96,English,,0,0,0,,And that was the cause that the software engineering institute runs an organization called cert the computer emergency response team
Dialogue: 0,0:38:32.22,0:38:39.96,Chinese,,0,0,0,,这就是软件工程学院运行一个名为cert的计算机应急响应团队的原因
Dialogue: 0,0:38:40.34,0:38:46.76,English,,0,0,0,,And that team was set up in response to this attack the Morris worm attack
Dialogue: 0,0:38:40.34,0:38:46.76,Chinese,,0,0,0,,该团队成立是为了应对莫里斯蠕虫攻击这一攻击
Dialogue: 0,0:38:48.10,0:38:56.03,English,,0,0,0,,We'll also see an interesting example between two companies in m
